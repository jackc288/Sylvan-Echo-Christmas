<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Christmas Magic Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: "Helvetica Neue", sans-serif; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* 1. é¡¶éƒ¨è‰ºæœ¯å­— */
        #top-title {
            position: absolute; top: 8vh; width: 100%; text-align: center;
            font-family: 'Georgia', serif; font-size: 3rem; font-weight: 800;
            background: linear-gradient(to bottom, #ffd700, #ffb300, #fff8e1);
            -webkit-background-clip: text; color: transparent;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
            z-index: 10; pointer-events: none; transition: opacity 0.5s;
        }

        /* 2. è°ƒè¯•é¢æ¿ */
        #debug-panel {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(4px);
            padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
            color: #00ff00; font-family: monospace; font-size: 12px;
            pointer-events: none; text-align: left; min-width: 120px;
        }

        /* 3. å¯åŠ¨é®ç½© */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; transition: opacity 0.5s;
        }
        #loading-text { margin-bottom: 20px; color: #ffca28; font-size: 14px; }
        #start-btn {
            padding: 15px 50px; font-size: 1.2rem; background: #333; border: 1px solid #555;
            border-radius: 30px; color: #888; cursor: not-allowed; transition: 0.3s;
        }
        #start-btn.ready {
            background: #ffb142; color: #000; font-weight: bold; border-color: #ffb142;
            box-shadow: 0 0 30px rgba(255, 177, 66, 0.6); animation: pulse 1.5s infinite; cursor: pointer;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* 4. ç¥ç¦å¼¹çª— */
        #message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 320px; padding: 25px;
            background: rgba(20, 20, 30, 0.7); backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,215,0,0.4); border-radius: 20px;
            color: #ffd700; font-size: 1.3rem; text-align: center;
            box-shadow: 0 0 50px rgba(255,215,0, 0.3);
            display: none; z-index: 30;
        }

        /* 5. åº•éƒ¨æŒ‰é’® */
        #ui-layer {
            position: absolute; bottom: 40px; left: 0; width: 100%;
            text-align: center; z-index: 10; pointer-events: none;
        }
        .btn-group {
            pointer-events: auto; background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px); padding: 8px; border-radius: 25px;
            display: inline-block; border: 1px solid rgba(255,255,255,0.1);
        }
        button.model-btn {
            background: transparent; color: rgba(255,255,255,0.7);
            border: none; padding: 10px 20px; margin: 0;
            border-radius: 20px; font-size: 14px; transition: 0.3s;
        }
        button.model-btn.active { background: rgba(255,215,0,0.8); color: black; font-weight: bold; }

        #video-preview {
            position: absolute; top: 0; left: 0; width: 1px; height: 1px;
            opacity: 0.01; pointer-events: none; transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-family: serif; font-size: 3rem; color: #ffd700; text-shadow:0 0 20px #ff4757;">Christmas<br>Magic</h1>
        <div id="loading-text">æ­£åœ¨å‡†å¤‡ç¤¼ç‰©...</div>
        <button id="start-btn" disabled>åŠ è½½ä¸­</button>
    </div>

    <div id="top-title">mm, Happy Christmas</div>

    <div id="debug-panel">
        <div>Hand: <span id="debug-hand">æœªæ£€æµ‹</span></div>
        <div>Color: <span id="debug-color">Gold</span></div>
        <div>State: <span id="debug-state">Wait</span></div>
    </div>
    
    <div id="message-box">
        ğŸ Merry Christmas ğŸ<br>
        <div style="font-size: 0.9rem; color: #fff; margin-top: 10px; opacity:0.8;">Make a Wish!</div>
    </div>

    <video id="video-preview" playsinline webkit-playsinline muted autoplay></video>

    <div id="ui-layer">
        <div class="btn-group">
            <button onclick="switchModel('hachiware')" id="btn-hachiware" class="model-btn active">å°å…«</button>
            <button onclick="switchModel('usagi')" id="btn-usagi" class="model-btn">ä¹Œè¨å¥‡</button>
            <button onclick="switchModel('chiikawa')" id="btn-chiikawa" class="model-btn">å‰ä¾å¡å“‡</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, controls;
        let treeGroup; 
        let starFieldGroup; 
        let snowParticles;  
        let ornaments = [];
        let flowParticles = []; 
        let starMesh; 
        let currentModel = null, currentModelName = 'hachiware';
        
        // å¯å˜æè´¨å¼•ç”¨ (é¢œè‰²åŒæ­¥)
        let matMutable; // é‡‘çƒ
        let matFlow;    // ç²’å­æµ
        let matSnow;    // é›ªèŠ±
        let matStar;    // é¡¶éƒ¨æ˜Ÿæ˜Ÿ
        let matFlashGroup = []; // éœ€è¦é—ªçƒçš„å…¶ä»–ç§¯æœ¨æè´¨

        // çŠ¶æ€
        let targetShape = 'tree'; 
        let handClenchLevel = 0;
        let isHandDetected = false;
        let previousHandX = 0;
        
        // å˜è‰²é€»è¾‘
        let colorState = 0; 
        let lastWaveTime = 0;
        // é¢œè‰²é…ç½®: Gold, Ice, Pink
        const COLORS = {
            0: { name: 'Gold', sphere: 0xffaa00, emissive: 0xff8800, snow: 0xffffff, flow: 0xfffee0 },
            1: { name: 'Ice',  sphere: 0x00ccff, emissive: 0x0066ff, snow: 0xaaddff, flow: 0xccffff },
            2: { name: 'Pink', sphere: 0xff69b4, emissive: 0xff1493, snow: 0xffc0cb, flow: 0xffe6ea }
        };

        const TREE_HEIGHT = 24;
        const TREE_RADIUS = 9;
        const ORNAMENT_COUNT = 4500;
        const FLOW_COUNT = 400; 

        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        const startBtn = document.getElementById('start-btn');
        const loadingText = document.getElementById('loading-text');
        
        // Debug
        const debugHand = document.getElementById('debug-hand');
        const debugColor = document.getElementById('debug-color');
        const debugState = document.getElementById('debug-state');

        // --- åˆå§‹åŒ– ---
        init3D();
        preloadAI();

        startBtn.addEventListener('click', async () => {
            if (startBtn.disabled) return;
            startBtn.innerText = "æ­£åœ¨å¯åŠ¨...";
            try {
                await startCamera();
                document.getElementById('start-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
                animate();
            } catch (e) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e);
            }
        });

        // --- åœºæ™¯ ---
        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.02);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = false;

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dl = new THREE.DirectionalLight(0xffd700, 1.5);
            dl.position.set(10, 20, 20);
            scene.add(dl);
            const spotLight = new THREE.SpotLight(0xffaa00, 300);
            spotLight.position.set(0, 30, 10);
            scene.add(spotLight);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            createBlockTree(); 
            createFlowParticles(); 
            createGoldenStar(); // é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            createOrionAndStars(); 
            createSnow();          

            loadMMDModel('hachiware');
            
            window.switchModel = (name) => {
                if (currentModelName === name) return;
                currentModelName = name;
                document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${name}`).classList.add('active');
                loadMMDModel(name);
            };
        }

        // --- è¾…åŠ©ï¼šç”Ÿæˆé›ªèŠ±è´´å›¾ ---
        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000'; ctx.fillRect(0,0,64,64); // èƒŒæ™¯é»‘(é€æ˜)
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            ctx.translate(32, 32);
            for(let i=0; i<6; i++) {
                ctx.beginPath();
                ctx.moveTo(0,0); ctx.lineTo(0, -28);
                ctx.moveTo(0, -18); ctx.lineTo(-10, -24);
                ctx.moveTo(0, -18); ctx.lineTo(10, -24);
                ctx.stroke();
                ctx.rotate(Math.PI / 3);
            }
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // --- 1. èƒŒæ™¯ï¼šçŒæˆ·åº§ ---
        function createOrionAndStars() {
            starFieldGroup = new THREE.Group();
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<1000; i++) {
                starPos.push((Math.random()-0.5)*200, (Math.random()-0.5)*100+20, (Math.random()-0.5)*100-50);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.4, transparent: true, opacity: 0.8 });
            starFieldGroup.add(new THREE.Points(starGeo, starMat));

            // çŒæˆ·åº§
            const orionStars = [[-10, 15, -60], [10, 12, -60], [-2, 5, -60], [0, 6, -60], [2, 7, -60], [-8, -8, -60], [12, -10, -60]];
            const orionGeo = new THREE.BufferGeometry();
            const orionPos = []; orionStars.forEach(p => orionPos.push(...p));
            orionGeo.setAttribute('position', new THREE.Float32BufferAttribute(orionPos, 3));
            const orionMat = new THREE.PointsMaterial({ color: 0xaaccff, size: 1.5, emissive: 0xffffff, emissiveIntensity: 1 });
            starFieldGroup.add(new THREE.Points(orionGeo, orionMat));

            scene.add(starFieldGroup);
        }

        // --- 2. é›ªèŠ± (Mod: çº¹ç† + å˜è‰²) ---
        function createSnow() {
            const particleCount = 2000;
            const geom = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            for(let i=0; i<particleCount; i++){
                positions.push((Math.random()-0.5)*120, Math.random()*80, (Math.random()-0.5)*100);
                velocities.push(0.05 + Math.random() * 0.1); 
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geom.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 1));

            // ä½¿ç”¨é›ªèŠ±è´´å›¾
            const tex = createSnowflakeTexture();
            matSnow = new THREE.PointsMaterial({
                color: COLORS[0].snow, 
                size: 1.2, // ç¨å¾®å¤§ä¸€ç‚¹çœ‹æ¸…é›ªèŠ±
                map: tex,
                transparent: true, 
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            snowParticles = new THREE.Points(geom, matSnow);
            snowParticles.visible = false;
            scene.add(snowParticles);
        }

        // --- 3. é¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ (Mod: å­˜åœ¨æ„Ÿ) ---
        function createGoldenStar() {
            const shape = new THREE.Shape();
            const outer = 1.5, inner = 0.6;
            for (let i=0; i<10; i++) {
                const rad = i * Math.PI * 0.2;
                const len = (i%2===0) ? outer : inner;
                const x = Math.cos(rad) * len;
                const y = Math.sin(rad) * len;
                if(i===0) shape.moveTo(x, y); else shape.lineTo(x, y);
            }
            shape.closePath();
            const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.5, bevelEnabled: true, bevelSegments: 2, bevelSize: 0.1, bevelThickness: 0.1 });
            
            // å¯å˜è‰²
            matStar = new THREE.MeshStandardMaterial({ 
                color: COLORS[0].sphere, 
                emissive: COLORS[0].emissive, 
                emissiveIntensity: 1.5, // é¡¶éƒ¨æ˜Ÿæ˜Ÿæ›´äº®
                roughness: 0.1, metalness: 0.9
            });
            
            starMesh = new THREE.Mesh(geometry, matStar);
            starMesh.position.set(0, TREE_HEIGHT/2 + 2, 0);
            
            const starLight = new THREE.PointLight(0xffffff, 2, 30);
            starMesh.add(starLight);
            
            treeGroup.add(starMesh);
        }

        // --- 4. ç§¯æœ¨æ ‘ (Mod: é‡‘çƒå˜å¤§å˜äº®ï¼Œå…¶ä»–é—ªçƒ) ---
        function createBlockTree() {
            const s = 0.18;
            
            const geoCube = new THREE.BoxGeometry(s, s, s);
            const geoTetra = new THREE.TetrahedronGeometry(s * 0.8);
            // é‡‘çƒå˜å¤§: s * 1.3
            const geoSphere = new THREE.SphereGeometry(s * 1.3, 16, 16);

            // é—ªçƒæè´¨ç»„ (éœ€è¦ç‹¬ç«‹å®ä¾‹ä»¥ä¾¿æ§åˆ¶emissive)
            // è¿™é‡Œæˆ‘ä»¬åˆ›å»ºåŸºç¡€æè´¨ï¼Œåœ¨ animate ä¸­æ§åˆ¶ emissiveIntensity
            const matGreen = new THREE.MeshStandardMaterial({ color: 0x20e647, roughness: 0.2, emissive: 0x003300 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff3838, roughness: 0.2, emissive: 0x330000 });
            const matSilver = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.1, emissive: 0x111111 });
            
            matFlashGroup = [matGreen, matRed, matSilver];

            // 80% ä¸»çƒæè´¨
            matMutable = new THREE.MeshStandardMaterial({
                color: COLORS[0].sphere,
                metalness: 0.9, roughness: 0.1,
                emissive: COLORS[0].emissive, 
                emissiveIntensity: 0.8 // åŸºç¡€äº®åº¦å¢åŠ 
            });

            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                let mesh, type;
                const r = Math.random();
                const scaleRand = 0.5 + Math.random(); 

                if (r < 0.80) {
                    mesh = new THREE.Mesh(geoSphere, matMutable);
                    type = 'mutable_sphere';
                } else {
                    let baseMat;
                    if (Math.random() < 0.33) baseMat = matGreen;
                    else if (Math.random() < 0.66) baseMat = matRed;
                    else baseMat = matSilver;
                    
                    mesh = new THREE.Mesh(geoCube, baseMat);
                    type = 'decoration';
                }
                
                mesh.scale.setScalar(scaleRand);

                // åˆå§‹ä½ç½®
                const spread = 60;
                mesh.position.set((Math.random()-0.5)*spread, (Math.random()-0.5)*spread, (Math.random()-0.5)*spread);
                
                // æ ‘å½¢æ€
                const yNorm = i / ORNAMENT_COUNT;
                const y = yNorm * TREE_HEIGHT - (TREE_HEIGHT / 2); 
                const radius = TREE_RADIUS * (1 - yNorm);
                const angle = Math.random() * Math.PI * 2; 

                treeGroup.add(mesh);
                ornaments.push({
                    mesh: mesh,
                    type: type,
                    // æ ‘çš„ç›®æ ‡ä½ç½®
                    treePos: new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius),
                    // æ‰©æ•£æ–¹å‘
                    explodeDir: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize(),
                    velocity: new THREE.Vector3()
                });
            }
        }

        // --- 5. æµåŠ¨ç²’å­ (Mod: å˜è‰²) ---
        function createFlowParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(FLOW_COUNT * 3);
            const speeds = new Float32Array(FLOW_COUNT);
            const offsets = new Float32Array(FLOW_COUNT);
            for (let i = 0; i < FLOW_COUNT; i++) {
                pos[i*3] = 0; pos[i*3+1] = 0; pos[i*3+2] = 0;
                speeds[i] = (0.05 + Math.random() * 0.15) * 0.66; 
                offsets[i] = Math.random() * Math.PI * 2;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            // å¯å˜è‰²
            matFlow = new THREE.PointsMaterial({
                color: COLORS[0].flow, 
                size: 0.4, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            });
            const points = new THREE.Points(geo, matFlow);
            treeGroup.add(points);
            flowParticles = { mesh: points, speeds: speeds, offsets: offsets };
        }

        // --- AI é€»è¾‘ ---
        let handLandmarker;
        async function preloadAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                startBtn.disabled = false; startBtn.classList.add('ready'); startBtn.innerText = "ç‚¹å‡»å¼€å¯é­”æ³•";
                loadingText.innerText = "å‡†å¤‡å°±ç»ª";
            } catch (e) { loadingText.innerText = "AI åŠ è½½å¤±è´¥"; }
        }

        async function startCamera() {
            const video = document.getElementById("video-preview");
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 640, height: 480 } });
            video.srcObject = stream;
            return new Promise(r => video.onloadeddata = () => { video.play(); r(); });
        }

        function loadMMDModel(name) {
            new MMDLoader().load(MODELS[name], (mesh) => {
                if (currentModel) scene.remove(currentModel);
                currentModel = mesh;
                mesh.scale.set(1.5, 1.5, 1.5);
                mesh.position.set(-22, -10, -5); 
                mesh.lookAt(0, -5, 0);
                mesh.material.forEach(m => {
                    m.emissive = new THREE.Color(0x333333);
                    if(name==='usagi') m.color.setHex(0xFFEEAA);
                    if(name==='hachiware') m.color.setHex(0xDDEEFF);
                });
                scene.add(mesh);
            });
        }

        // --- å˜è‰²è§¦å‘å™¨ (é«˜çµæ•åº¦) ---
        function triggerColorChange() {
            const now = Date.now();
            if (now - lastWaveTime < 600) return; // å†·å´ 0.6s
            lastWaveTime = now;

            colorState = (colorState + 1) % 3;
            const c = COLORS[colorState];
            
            // åŒæ­¥æ‰€æœ‰é¢œè‰²
            matMutable.color.setHex(c.sphere);
            matMutable.emissive.setHex(c.emissive);
            
            matStar.color.setHex(c.sphere);
            matStar.emissive.setHex(c.emissive);

            matFlow.color.setHex(c.flow);
            matSnow.color.setHex(c.snow);

            debugColor.innerText = c.name;
            debugColor.style.color = '#' + c.sphere.toString(16);
        }

        let lastVideoTime = -1;
        function updateLogic() {
            const video = document.getElementById("video-preview");
            if (!handLandmarker || !video || video.paused) return;

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const res = handLandmarker.detectForVideo(video, performance.now());
                const msgBox = document.getElementById('message-box');
                const title = document.getElementById('top-title');

                if (res.landmarks && res.landmarks.length > 0) {
                    isHandDetected = true;
                    const lm = res.landmarks[0];
                    const wrist = lm[0];
                    
                    debugHand.innerText = "å·²æ£€æµ‹"; debugHand.style.color = "#00ff00";

                    // 1. æ¡æ‹³
                    const tips = [8,12,16,20];
                    let dist = 0;
                    tips.forEach(i => dist += Math.sqrt(Math.pow(lm[i].x-wrist.x,2) + Math.pow(lm[i].y-wrist.y,2)));
                    dist /= 4;
                    let rawClench = THREE.MathUtils.mapLinear(dist, 0.45, 0.2, 0, 1);
                    handClenchLevel += (THREE.MathUtils.clamp(rawClench, 0, 1) - handClenchLevel) * 0.15;

                    // 2. çŠ¶æ€åˆ¤å®š
                    if (handClenchLevel > 0.7) { 
                        targetShape = 'ball'; // Mod: å˜æˆçƒ
                        debugState.innerText = "Fist (Ball)"; debugState.style.color = "#ffd700";
                    } else if (handClenchLevel < 0.3) { 
                        targetShape = 'firework'; 
                        debugState.innerText = "Palm (Explode)"; debugState.style.color = "#ff4757";
                    } else {
                        targetShape = 'tree';
                        debugState.innerText = "Normal Tree"; debugState.style.color = "#fff";
                    }

                    // 3. çµæ•å˜è‰²æ£€æµ‹
                    // è®¡ç®—æ‰‹æŒæ°´å¹³é€Ÿåº¦
                    const rawX = 0.5 - wrist.x;
                    const delta = rawX - previousHandX;
                    // é™ä½é˜ˆå€¼ 0.08 -> 0.025 (æ›´çµæ•)
                    if (Math.abs(delta) > 0.025) { 
                        triggerColorChange();
                    }
                    previousHandX = rawX;

                    // 4. OKæ‰‹åŠ¿
                    const pinch = Math.sqrt(Math.pow(lm[4].x-lm[8].x,2) + Math.pow(lm[4].y-lm[8].y,2));
                    const middle = Math.sqrt(Math.pow(lm[12].x-wrist.x,2) + Math.pow(lm[12].y-wrist.y,2));
                    if (pinch < 0.06 && middle > 0.25) {
                        msgBox.style.display = 'block'; title.style.opacity = 0;
                    } else {
                        msgBox.style.display = 'none'; title.style.opacity = 1;
                    }

                } else {
                    isHandDetected = false;
                    handClenchLevel = 0;
                    targetShape = 'tree'; 
                    debugHand.innerText = "æœªæ£€æµ‹"; debugHand.style.color = "#ff0000";
                    debugState.innerText = "Auto Rotate";
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateLogic();
            
            const time = Date.now() * 0.001;

            // --- 0. é—ªçƒé€»è¾‘ (0.5s å‘¨æœŸ) ---
            const flashState = (Date.now() % 500) < 250; // 250msäº®ï¼Œ250msæš—
            matFlashGroup.forEach(m => {
                // åŸºç¡€è‰²æ˜¯é»‘/æš—è‰²ï¼Œé—ªçƒæ—¶å˜äº®
                m.emissiveIntensity = flashState ? 2.0 : 0.2;
            });

            // --- èƒŒæ™¯é€»è¾‘ ---
            if (isHandDetected) {
                if(starFieldGroup) starFieldGroup.visible = false;
                if(snowParticles) snowParticles.visible = true;
                treeGroup.rotation.y += 0.001; 
            } else {
                if(starFieldGroup) starFieldGroup.visible = true;
                if(snowParticles) snowParticles.visible = false;
                treeGroup.rotation.y += 0.005;
                if (colorState !== 0) { // æ— æ‰‹å¤ä½é‡‘è‰²
                     colorState = 0;
                     const c = COLORS[0];
                     matMutable.color.setHex(c.sphere); matMutable.emissive.setHex(c.emissive);
                     matStar.color.setHex(c.sphere); matStar.emissive.setHex(c.emissive);
                     matFlow.color.setHex(c.flow); matSnow.color.setHex(c.snow);
                }
            }

            // é›ªèŠ±ç‰©ç†
            if(snowParticles && snowParticles.visible) {
                const positions = snowParticles.geometry.attributes.position.array;
                const vels = snowParticles.geometry.attributes.velocity.array;
                for(let i=0; i<vels.length; i++) {
                    const idx = i * 3;
                    positions[idx+1] -= vels[i]; 
                    if(positions[idx+1] < -20) positions[idx+1] = 50;
                }
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }

            // --- ç§¯æœ¨ç‰©ç† (å…³é”®é€»è¾‘) ---
            // ç›®æ ‡ä¸­å¿ƒç‚¹
            const center = new THREE.Vector3(0, 0, 0);

            ornaments.forEach(p => {
                const cur = p.mesh.position;

                if (isHandDetected) {
                    if (targetShape === 'firework') {
                        // å¼ æ‰‹ï¼šæ‰©æ•£
                        p.velocity.copy(p.explodeDir).multiplyScalar(0.5); 
                        cur.add(p.velocity);
                        p.mesh.rotation.x += 0.05;
                    } else if (targetShape === 'ball') {
                        // æ¡æ‹³ï¼šç¼©æˆå…‰çƒ (æ‰€æœ‰ç‚¹å» (0,0,0))
                        cur.lerp(center, 0.1); 
                        p.velocity.set(0,0,0);
                        p.mesh.rotation.x += 0.1; // å¿«é€Ÿè‡ªæ—‹
                    } else {
                        // å¾®æ¡/è¿‡æ¸¡ï¼šå›æ ‘
                        cur.lerp(p.treePos, 0.1);
                        p.velocity.set(0,0,0);
                    }
                } else {
                    // æ— æ‰‹ï¼šå›æ ‘
                    cur.lerp(p.treePos, 0.1);
                    p.velocity.set(0,0,0);
                }
            });

            // é¡¶éƒ¨æ˜Ÿæ˜Ÿä½ç½®è·Ÿéš (å¦‚æœæ˜¯çƒä½“æ¨¡å¼ï¼Œæ˜Ÿæ˜Ÿä¹Ÿè¯¥ä¸‹å»å—ï¼Ÿé€šå¸¸æ˜Ÿæ˜Ÿä¿æŒé¡¶éƒ¨æˆ–è·Ÿç€ç¼©)
            // è¿™é‡Œè®©æ˜Ÿæ˜Ÿåœ¨æ¡æ‹³æ—¶ä¹Ÿç¨å¾®ä¸‹é™ä¸€ç‚¹ç‚¹ï¼Œæ›´æœ‰æ•´ä½“æ„Ÿ
            if (targetShape === 'ball' && isHandDetected) {
                starMesh.position.lerp(new THREE.Vector3(0, 0, 0), 0.05);
                starMesh.scale.setScalar(0.1); // ç¼©å°æ¶ˆå¤±åœ¨å…‰çƒé‡Œ
            } else {
                starMesh.position.lerp(new THREE.Vector3(0, TREE_HEIGHT/2 + 2, 0), 0.1);
                starMesh.scale.setScalar(1);
            }

            // æµå…‰ç²’å­
            if (flowParticles.mesh) {
                const pos = flowParticles.mesh.geometry.attributes.position.array;
                for(let i=0; i<FLOW_COUNT; i++) {
                    const idx = i*3;
                    pos[idx+1] += flowParticles.speeds[i]; 
                    
                    const angle = time * 0.8 + flowParticles.offsets[i];
                    const normalizedY = (pos[idx+1] + TREE_HEIGHT/2) / TREE_HEIGHT;
                    let r = TREE_RADIUS * 1.2 * (1 - normalizedY * 0.7);
                    
                    if(targetShape === 'firework') r *= 1.5;
                    // æ¡æ‹³æ—¶ç²’å­ä¹Ÿæ”¶ç¼©
                    if(targetShape === 'ball') r *= 0.2;

                    pos[idx] = Math.cos(angle) * r;
                    pos[idx+2] = Math.sin(angle) * r;

                    if (pos[idx+1] > TREE_HEIGHT/2 + 2) pos[idx+1] = -TREE_HEIGHT/2 - 2;
                }
                flowParticles.mesh.geometry.attributes.position.needsUpdate = true;
            }

            // äººç‰©æ‰‹è‡‚
            if (currentModel && currentModel.skeleton) {
                const bones = currentModel.skeleton.bones;
                const armL = bones.find(b => b.name === 'å·¦è…•');
                const armR = bones.find(b => b.name === 'å³è…•');
                if (armL && armR) {
                    const z = THREE.MathUtils.lerp(-0.8, 0.6, handClenchLevel);
                    const x = THREE.MathUtils.lerp(0, -0.6, handClenchLevel);
                    armL.rotation.z = z; armL.rotation.x = x;
                    armR.rotation.z = -z; armR.rotation.x = x;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
