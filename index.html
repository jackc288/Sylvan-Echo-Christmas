<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sylvan Echo Christmas</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: #000; 
            font-family: 'Cinzel', serif;
            user-select: none; -webkit-user-select: none;
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        #top-title {
            position: absolute; top: 5%; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }
        #top-title h1 {
            font-family: 'Great Vibes', cursive; font-size: 3rem; color: #ffdae0; margin: 0;
            text-shadow: 0 0 15px rgba(255, 182, 193, 0.8), 0 0 30px rgba(255, 105, 180, 0.5);
            animation: breathe 4s infinite ease-in-out;
        }
        @keyframes breathe { 50% { opacity: 0.8; text-shadow: 0 0 40px rgba(255, 105, 180, 1); } }

        /* æ‘„åƒå¤´é¢„è§ˆ - å…³é”®ä¿®å¤ï¼šç¡®ä¿å¯è§æ€§ */
        #camera-container {
            position: absolute; bottom: 20px; left: 20px; 
            width: 120px; height: 160px; /* ç«–å±æ¯”ä¾‹ */
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255, 105, 180, 0.5);
            z-index: 20; background: #000;
        }
        #camera-preview {
            width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.8;
        }

        /* æ‰‹åŠ¿æŒ‡å¼• */
        #gesture-guide {
            position: absolute; top: 15%; right: 20px; width: 180px;
            background: rgba(0,0,0,0.4); padding: 15px; border-radius: 12px;
            border-right: 3px solid #ff69b4; color: #ddd; font-size: 0.8rem; 
            z-index: 15; pointer-events: none; backdrop-filter: blur(4px);
        }
        .g-item { margin-bottom: 8px; opacity: 0.5; transition: 0.3s; display: flex; align-items: center; justify-content: flex-end; text-align: right;}
        .g-item.active { opacity: 1; color: #fff; font-weight: bold; text-shadow: 0 0 8px #ff69b4; transform: scale(1.05); }

        /* åº•éƒ¨æŒ‰é’® */
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 20;
            background: rgba(20, 20, 30, 0.6); padding: 10px 20px; border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(5px);
        }
        .btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white;
            padding: 8px 16px; border-radius: 20px; cursor: pointer; 
            font-family: 'Cinzel', serif; font-size: 0.8rem; transition: 0.3s;
        }
        .btn:hover, .btn.active { background: #ff69b4; border-color: #ff69b4; color: #000; box-shadow: 0 0 15px #ff69b4; }

        /* Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffdae0; transition: opacity 1s;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #ff69b4;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 600px) {
            #top-title h1 { font-size: 2rem; }
            #gesture-guide { transform: scale(0.8); top: 10%; right: 5px; transform-origin: top right; }
            #camera-container { width: 90px; height: 120px; bottom: 90px; left: 10px; }
            #controls { bottom: 20px; width: 85%; overflow-x: auto; justify-content: flex-start; }
            .btn { white-space: nowrap; }
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">Loading Magic...</div>
        <button id="start-btn" class="btn" style="display:none; margin-top:20px; font-size: 1.2rem; padding: 10px 40px;">å¼€å¯åœ£è¯</button>
    </div>

    <div id="top-title"><h1>Sylvan Echo Christmas</h1></div>

    <div id="camera-container">
        <video id="camera-preview" playsinline muted autoplay></video>
    </div>

    <div id="gesture-guide">
        <div class="g-item" id="g-tree">ğŸ– è‡ªç”±è§†è§’</div>
        <div class="g-item" id="g-pinch">ğŸ‘Œ æåˆ: æ£€è§†ç…§ç‰‡</div>
        <div class="g-item" id="g-burst">ğŸ‘‹ æŒ¥æ‰‹: æ—‹è½¬</div>
    </div>

    <div id="controls">
        <button class="btn" id="music-btn">ğŸµ Music</button>
        <button class="btn active" onclick="switchModel('hachiware')">å°å…«</button>
        <button class="btn" onclick="switchModel('usagi')">ä¹Œè¨å¥‡</button>
        <button class="btn" onclick="switchModel('chiikawa')">å‰ä¾å¡å“‡</button>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer;
        let mainTreeInstanced, phantomTreePoints, topStar;
        let photoGroup = new THREE.Group(); // å­˜æ”¾æ‰€æœ‰ç…§ç‰‡ Mesh
        let snowSystem;
        let orionGroup;
        
        // æ ¸å¿ƒï¼šç…§ç‰‡äº¤äº’å˜é‡
        const PRESET_PHOTOS = ['love1.jpg', 'love2.jpg', 'love3.jpg', 'love4.jpg', 'love5.jpg', 'love1.jpg', 'love2.jpg']; // å»ºè®®å¤šæ”¾å‡ å¼ å›¾ç‰‡æµ‹è¯•
        let targetPhotoIndex = -1; // å½“å‰èšç„¦çš„ç…§ç‰‡ç´¢å¼•
        let isPinching = false;
        const tempVec = new THREE.Vector3();
        const tempQuat = new THREE.Quaternion();

        // çŠ¶æ€
        let handVelocityX = 0; 
        let sceneRotation = 0;
        let lastHandX = 0;
        
        // æ¨¡å‹
        let currentModel = null;
        const MODELS = { 'hachiware': './hachiware.pmx', 'usagi': './usagi.pmx', 'chiikawa': './chiikawa.pmx' };
        
        // å¸¸é‡
        const TREE_H = 28;
        const TREE_R = 11;
        const P_COUNT = 1200; // ç²’å­æ•°é‡
        let clock = new THREE.Clock();
        let audioCtx, isMusicPlaying = false;

        // --- åˆå§‹åŒ–å…¥å£ ---
        window.onload = async () => {
            try {
                await initAI();
                document.getElementById('loading-text').innerText = "Ready";
                document.getElementById('start-btn').style.display = 'block';
            } catch (e) {
                alert("AIåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–åˆ·æ–°: " + e);
            }
        };

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
            
            initThree();
            initAudio();
            startCamera(); // å¯åŠ¨æ‘„åƒå¤´
            loadModel('hachiware');
            loadPhotosDistributed(); // æ–°çš„åˆ†å¸ƒé€»è¾‘
            animate();
        });

        // --- 1. Three.js åœºæ™¯æ„å»º ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); // é»‘è‰²é›¾ï¼Œå¢å¼ºæ·±é‚ƒæ„Ÿ

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 45); // ç¨å¾®æŠ¬é«˜è§†è§’

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);

            // POST PROCESSING: å¼ºè¾‰å…‰æ•ˆæœ
            const renderPass = new RenderPass(scene, camera);
            // å‚æ•°: åˆ†è¾¨ç‡, strength(å¼ºåº¦), radius(åŠå¾„), threshold(é˜ˆå€¼)
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.5, 0.1);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // ç¯å…‰ (ç”¨äºç…§äº® InstancedMesh çƒä½“)
            const ambient = new THREE.AmbientLight(0x444444);
            const dirLight = new THREE.DirectionalLight(0xffd700, 2);
            dirLight.position.set(10, 20, 20);
            const pointLight = new THREE.PointLight(0xff69b4, 1, 50);
            pointLight.position.set(0, 10, 0);
            scene.add(ambient, dirLight, pointLight);

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createMainTreeInstanced(); // å®ä½“ç²’å­æ ‘
            createPhantomTree();       // å¹»å½±æ ‘
            createTopStar();
            createSnow();
            createOrion();
            
            scene.add(photoGroup);

            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. ä¸»åœ£è¯æ ‘ (InstancedMesh + MeshStandardMaterial) ---
        function createMainTreeInstanced() {
            // ä½¿ç”¨çƒä½“å‡ ä½•ä½“ï¼Œæ»¡è¶³å‘å…‰çƒä½“ç²’å­çš„è¦æ±‚
            const geometry = new THREE.SphereGeometry(0.18, 16, 16);
            
            // ä½¿ç”¨ MeshStandardMaterial å®ç°é«˜å…‰å’Œè¾‰å…‰
            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x000000, // åˆå§‹ä¸å‘å…‰ï¼Œé€šè¿‡ instanceColor æ§åˆ¶
                emissiveIntensity: 1.0
            });

            mainTreeInstanced = new THREE.InstancedMesh(geometry, material, P_COUNT);
            
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            const c_gold = new THREE.Color(0xD4AF37);
            const c_pink = new THREE.Color(0xFF69B4);

            for (let i = 0; i < P_COUNT; i++) {
                // åœ†é”¥èºæ—‹æ’åˆ—
                const rRatio = i / P_COUNT; // 0 (é¡¶) -> 1 (åº•)
                const y = TREE_H/2 - rRatio * TREE_H; // ä»ä¸Šåˆ°ä¸‹
                const r = rRatio * TREE_R; // åŠå¾„é€æ¸å˜å¤§
                
                const angle = i * 0.5; // èºæ—‹å¯†åº¦
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                dummy.position.set(x, y, z);
                dummy.scale.setScalar(0.5 + Math.random()); // å¤§å°éšæœº
                dummy.updateMatrix();
                mainTreeInstanced.setMatrixAt(i, dummy.matrix);

                // é¢œè‰²éšæœºæ··åˆ
                if (Math.random() > 0.6) {
                    color.copy(c_gold); // é‡‘è‰²
                    // é‡‘è‰²ç²’å­ç¨å¾®äº®ä¸€ç‚¹
                    color.multiplyScalar(1.2);
                } else {
                    color.copy(c_pink); // ç²‰è‰²
                    color.multiplyScalar(1.5); // ç²‰è‰²æ›´äº®ä»¥è§¦å‘ Bloom
                }
                mainTreeInstanced.setColorAt(i, color);
            }
            
            mainTreeInstanced.instanceMatrix.needsUpdate = true;
            mainTreeInstanced.instanceColor.needsUpdate = true;
            scene.add(mainTreeInstanced);
        }

        // --- 3. å¹»å½±æ ‘ (Points + Vertex Colors æ¸å˜) ---
        function createPhantomTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const count = 1000;
            
            // é¢œè‰²å®šä¹‰
            const c_top = new THREE.Color(0xFFB6C1); // äº®ç²‰
            const c_bottom = new THREE.Color(0x8B008B); // æ·±ç´«

            for(let i=0; i<count; i++) {
                const rRatio = i / count;
                const y = (TREE_H * 0.8)/2 - rRatio * (TREE_H * 0.8);
                const r = rRatio * (TREE_R * 0.6); // ç¨å¾®å°ä¸€ç‚¹ï¼Œåœ¨å†…éƒ¨
                const angle = i * 0.3;

                positions.push(Math.cos(angle)*r, y, Math.sin(angle)*r);

                // æ¸å˜è®¡ç®—ï¼šé¡¶éƒ¨äº®ï¼Œåº•éƒ¨æš—
                const mixColor = c_bottom.clone().lerp(c_top, 1 - rRatio);
                colors.push(mixColor.r, mixColor.g, mixColor.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true, // å¼€å¯é¡¶ç‚¹é¢œè‰²
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            phantomTreePoints = new THREE.Points(geometry, material);
            scene.add(phantomTreePoints);
        }

        // --- 4. ç…§ç‰‡åˆ†å¸ƒ (Fibonacci Sphere å˜ç§) ---
        function loadPhotosDistributed() {
            const loader = new THREE.TextureLoader();
            // æ–æ³¢é‚£å¥‘èºæ—‹ç®—æ³•ï¼Œä¿è¯å‡åŒ€åˆ†å¸ƒåœ¨åœ†é”¥é¢ä¸Š
            const count = PRESET_PHOTOS.length;
            const goldenRatio = (1 + Math.sqrt(5)) / 2;

            PRESET_PHOTOS.forEach((src, i) => {
                loader.load(src, (tex) => {
                    tex.colorSpace = 'srgb';
                    // ä¿æŒå›¾ç‰‡æ¯”ä¾‹
                    const aspect = tex.image.width / tex.image.height;
                    const baseH = 5; 
                    const geometry = new THREE.PlaneGeometry(baseH * aspect, baseH);
                    const material = new THREE.MeshBasicMaterial({ 
                        map: tex, side: THREE.DoubleSide, transparent: true 
                    });
                    const mesh = new THREE.Mesh(geometry, material);

                    // è®¡ç®—ä½ç½®ï¼šå‡åŒ€åˆ†å¸ƒåœ¨æ ‘å‘¨å›´
                    const y = TREE_H/2 - (i / (count - 0.99)) * TREE_H * 0.8; // å‚ç›´åˆ†å¸ƒ
                    const r = (TREE_R + 4) * (1 - (y + TREE_H/2)/TREE_H) + 2; // åŠå¾„éšé«˜åº¦å˜åŒ–ï¼Œä½†åœ¨æ ‘å¤–åœˆ
                    
                    const theta = 2 * Math.PI * i / goldenRatio; // è§’åº¦å‡åŒ€æ‰“æ•£
                    
                    const x = Math.cos(theta) * r;
                    const z = Math.sin(theta) * r;

                    // å­˜å‚¨åŸå§‹ä½ç½®æ•°æ®
                    mesh.userData = {
                        homePos: new THREE.Vector3(x, y, z),
                        homeScale: 1,
                        id: i
                    };
                    
                    mesh.position.copy(mesh.userData.homePos);
                    mesh.lookAt(0, y, 0); // åˆå§‹é¢å‘æ ‘å¹²
                    
                    photoGroup.add(mesh);
                });
            });
        }

        // --- 5. äº¤äº’æ ¸å¿ƒé€»è¾‘ (Pinch Focus) ---
        function updatePhotoInteraction() {
            if (!photoGroup.children.length) return;

            // 1. å¦‚æœæ­£åœ¨æåˆï¼Œæ‰¾åˆ°ç¦»å±å¹•ä¸­å¿ƒæœ€è¿‘çš„ç…§ç‰‡
            if (isPinching) {
                if (targetPhotoIndex === -1) {
                    // è®¡ç®—æœ€è¿‘çš„ç…§ç‰‡
                    let minDist = Infinity;
                    photoGroup.children.forEach((mesh, idx) => {
                        // å°†ç…§ç‰‡ä¸–ç•Œåæ ‡è½¬ä¸ºå±å¹•åæ ‡
                        const screenPos = mesh.position.clone().project(camera);
                        const dist = screenPos.distanceTo(new THREE.Vector3(0,0,0)); // è·ä¸­å¿ƒè·ç¦»
                        if (dist < minDist) {
                            minDist = dist;
                            targetPhotoIndex = idx;
                        }
                    });
                }
            } else {
                targetPhotoIndex = -1; // é‡Šæ”¾é”å®š
            }

            // 2. æ›´æ–°æ¯å¼ ç…§ç‰‡çš„ä½ç½®
            photoGroup.children.forEach((mesh, idx) => {
                const isTarget = (idx === targetPhotoIndex);

                if (isTarget && isPinching) {
                    // --- é€‰ä¸­çŠ¶æ€ï¼šç£å¸å±…ä¸­ ---
                    
                    // A. è®¡ç®—ç›®æ ‡ä½ç½®ï¼šæ‘„åƒæœºå‰æ–¹å›ºå®šè·ç¦»
                    const distToCam = 25; // è·ç¦»æ‘„åƒæœºå¤šè¿œ
                    // è·å–æ‘„åƒæœºæ­£å‰æ–¹çš„ç‚¹
                    const targetPos = new THREE.Vector3(0, 0, -distToCam);
                    targetPos.applyQuaternion(camera.quaternion);
                    targetPos.add(camera.position);

                    // B. è®¡ç®—ç›®æ ‡ç¼©æ”¾ï¼šå å±å¹•é«˜åº¦ 70%
                    // å¯è§†é«˜åº¦ = 2 * tan(fov/2) * distance
                    const vFOV = THREE.MathUtils.degToRad(camera.fov);
                    const visibleHeight = 2 * Math.tan(vFOV / 2) * distToCam;
                    const targetHeight = visibleHeight * 0.7; // 70%
                    const scaleFactor = targetHeight / mesh.geometry.parameters.height;

                    // C. åŠ¨ç”»æ’å€¼ (Lerp)
                    mesh.position.lerp(targetPos, 0.15); // ç§»åŠ¨
                    mesh.quaternion.slerp(camera.quaternion, 0.15); // æ—‹è½¬è‡³å¹³è¡Œå±å¹•
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, scaleFactor, 0.15));

                } else {
                    // --- å½’ä½çŠ¶æ€ ---
                    // éšæ•´ä½“æ—‹è½¬
                    const worldRot = sceneRotation; 
                    const home = mesh.userData.homePos;
                    
                    // æ‰‹åŠ¨è®¡ç®—æ—‹è½¬åçš„ä¸–ç•Œä½ç½® (ç®€å•ç»•Yè½´)
                    const x = home.x * Math.cos(worldRot) - home.z * Math.sin(worldRot);
                    const z = home.x * Math.sin(worldRot) + home.z * Math.cos(worldRot);
                    
                    const targetPos = new THREE.Vector3(x, home.y, z);
                    
                    mesh.position.lerp(targetPos, 0.1);
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, 1, 0.1));
                    
                    // è®©æœªé€‰ä¸­çš„ç…§ç‰‡çœ‹å‘æ‘„åƒæœºï¼Œä½†ä¿æŒåœ¨åŸä½
                    mesh.lookAt(camera.position); 
                }
            });
        }

        // --- 6. AI ä¸ æ‘„åƒå¤´ (ä¿®å¤æ‰‹æœºç«¯) ---
        let handLandmarker;
        
        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });
        }

        async function startCamera() {
            const video = document.getElementById('camera-preview');
            // æ‰‹æœºç«¯å…³é”®é…ç½®
            const constraints = {
                video: {
                    facingMode: "user",
                    width: { ideal: 640 }, // é™åˆ¶åˆ†è¾¨ç‡æé«˜æ€§èƒ½
                    height: { ideal: 480 }
                }
            };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    predictWebcam();
                });
            } catch (err) {
                console.error("Camera Error:", err);
                alert("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿ç»™äºˆæƒé™å¹¶åœ¨HTTPSç¯å¢ƒä¸‹è¿è¡Œã€‚");
            }
        }

        let lastVideoTime = -1;
        function predictWebcam() {
            const video = document.getElementById('camera-preview');
            // ç¡®ä¿è§†é¢‘æ­£åœ¨æ’­æ”¾ä¸”æœ‰æ•°æ®
            if (video.videoWidth > 0 && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const startTimeMs = performance.now();
                
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, startTimeMs);
                    processGestures(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(result) {
            const guideItems = document.querySelectorAll('.g-item');
            guideItems.forEach(i => i.classList.remove('active'));

            let detectedPinch = false;
            let detectedPalm = false;

            if (result.landmarks.length > 0) {
                const lm = result.landmarks[0];
                const thumbTip = lm[4];
                const indexTip = lm[8];
                const wrist = lm[0];

                // 1. è®¡ç®—æ‰‹é€Ÿ (Xè½´ç§»åŠ¨) ç”¨äºæ—‹è½¬
                const cx = wrist.x;
                if (Math.abs(cx - lastHandX) > 0.005) {
                    handVelocityX = (cx - lastHandX) * -8; // çµæ•åº¦
                }
                lastHandX = cx;

                // 2. æ£€æµ‹æåˆ (Pinch) - æ‹‡æŒ‡ä¸é£ŸæŒ‡è·ç¦»
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                if (pinchDist < 0.08) { 
                    detectedPinch = true;
                    document.getElementById('g-pinch').classList.add('active');
                } else {
                    // 3. æ£€æµ‹å¼ æ‰‹ (Burst/Palm) - æŒ‡å°–è¿œç¦»æ‰‹è…•
                    // ç®€å•åˆ¤æ–­ï¼šé£ŸæŒ‡æŒ‡å°–åˆ°æ‰‹è…•è·ç¦»è¾ƒè¿œ
                    const extendDist = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
                    if (extendDist > 0.3) {
                        detectedPalm = true;
                        document.getElementById('g-burst').classList.add('active');
                    }
                }
            } else {
                // æ— æ‰‹åŠ¿ï¼Œç¼“æ…¢å‡é€Ÿ
                handVelocityX *= 0.9;
                document.getElementById('g-tree').classList.add('active');
            }

            isPinching = detectedPinch;
        }

        // --- 7. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // åœºæ™¯æ—‹è½¬ (æ‰‹åŠ¿æ§åˆ¶ + è‡ªåŠ¨æ…¢è½¬)
            if (!isPinching) {
                sceneRotation += handVelocityX * 0.05 + 0.002;
            }
            // åº”ç”¨æ—‹è½¬åˆ°å„ç»„ (é™¤äº†æ­£åœ¨è¢«é€‰ä¸­çš„ç…§ç‰‡)
            if (mainTreeInstanced) mainTreeInstanced.rotation.y = sceneRotation;
            if (phantomTreePoints) phantomTreePoints.rotation.y = sceneRotation;
            if (snowSystem) snowSystem.rotation.y = sceneRotation * 0.5;

            // å‘¼å¸ç¯æ•ˆ
            if (mainTreeInstanced) {
                // ç®€å•çš„æ•´ä½“ç¼©æ”¾æ¨¡æ‹Ÿå‘¼å¸
                const s = 1 + Math.sin(time * 2) * 0.01;
                mainTreeInstanced.scale.set(s, s, s);
            }

            // æ›´æ–°ç…§ç‰‡é€»è¾‘
            updatePhotoInteraction();

            // æ›´æ–°å…¶ä»–ç»„ä»¶
            updateSnow();
            if (topStar) topStar.rotation.y -= 0.02;
            
            composer.render();
        }

        // --- è¾…åŠ©å‡½æ•° ---
        function createTopStar() {
            const geometry = new THREE.IcosahedronGeometry(1.5, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700, emissive: 0xffaa00, emissiveIntensity: 2, roughness: 0.1
            });
            topStar = new THREE.Mesh(geometry, material);
            topStar.position.set(0, TREE_H/2 + 1, 0);
            scene.add(topStar);
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const p = [];
            for(let i=0;i<800;i++) p.push((Math.random()-0.5)*60,(Math.random()-0.5)*60+10,(Math.random()-0.5)*60);
            geo.setAttribute('position',new THREE.Float32BufferAttribute(p,3));
            snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({color:0xffffff,size:0.2,transparent:true,opacity:0.6}));
            scene.add(snowSystem);
        }
        
        function updateSnow() {
            const p = snowSystem.geometry.attributes.position.array;
            for(let i=1;i<p.length;i+=3) {
                p[i] -= 0.1;
                if(p[i] < -20) p[i] = 30;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        function createOrion() {
            orionGroup = new THREE.Group();
            // ç®€å•æ¨¡æ‹ŸçŒæˆ·åº§ä½ç½®
            const starsData = [
                [-5, 5, 0], [5, 3, 0], // è‚©è†€
                [-1, 0, 0], [0, 1, 0], [1, 0, 0], // è…°å¸¦
                [-4, -6, 0], [6, -5, 0] // è†ç›–
            ];
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({color: 0xffffff});
            
            starsData.forEach(pos => {
                const s = new THREE.Mesh(geo, mat);
                s.position.set(...pos);
                orionGroup.add(s);
            });
            orionGroup.position.set(20, 20, -30);
            orionGroup.scale.setScalar(2);
            scene.add(orionGroup);
        }
        
        // éŸ³é¢‘ä¸æ¨¡å‹åŠ è½½å‡½æ•°ä¿ç•™åŸé€»è¾‘ï¼ˆç®€åŒ–ç‰ˆï¼‰
        function initAudio() { audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
        
        function loadModel(name) {
            if(!MODELS[name]) return;
            new MMDLoader().load(MODELS[name], (m)=>{
                if(currentModel) scene.remove(currentModel);
                currentModel=m;
                m.position.set(0, -15, 0); // æ”¾åœ¨æ ‘ä¸‹
                m.scale.setScalar(0.5);
                scene.add(m);
            });
        }
        window.switchModel = (n) => { loadModel(n); };
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
