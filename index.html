<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Christmas Interactive</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: "Helvetica Neue", sans-serif; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* 1. é¡¶éƒ¨æ ‡é¢˜ */
        #top-title {
            position: absolute;
            top: 5vh;
            width: 100%;
            text-align: center;
            font-family: 'Georgia', serif;
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(to right, #ff4757, #2ed573, #ffa502);
            -webkit-background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            z-index: 10;
            pointer-events: none;
        }

        /* 3. OK æ‰‹åŠ¿å¼¹çª— */
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 300px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 15px;
            color: #fff;
            font-size: 1.2rem;
            text-align: center;
            box-shadow: 0 0 20px rgba(255,215,0, 0.3);
            display: none; /* é»˜è®¤éšè— */
            z-index: 30;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* iOS å¯åŠ¨é®ç½©å±‚ */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        #start-btn {
            padding: 15px 40px;
            margin-top: 20px;
            font-size: 1.2rem;
            background: #ff4757;
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 15px #ff4757;
        }

        /* åº•éƒ¨ UI */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        .btn-group {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            padding: 10px;
            border-radius: 20px;
            display: inline-block;
        }
        button {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 12px;
            font-size: 14px;
        }
        button.active { background: #ff4757; border-color: #ff4757; }

        /* è°ƒè¯•/çŠ¶æ€æ–‡å­— */
        #status-text {
            position: absolute;
            top: 10px; left: 10px;
            color: rgba(255,255,255,0.5);
            font-size: 10px;
            z-index: 5;
        }

        /* è§†é¢‘æº (iOS å¿…é¡»è®¾ä¸ºå¯è§ä½†é€æ˜) */
        #video-preview {
            position: absolute;
            top: 0; left: 0;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
            transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1>ğŸ„ åœ£è¯äº’åŠ¨</h1>
        <p>éœ€è¦æ‘„åƒå¤´æƒé™</p>
        <button id="start-btn">ç‚¹å‡»å¼€å§‹ä½“éªŒ</button>
    </div>

    <div id="top-title">mm, Happy Christmas</div>
    
    <div id="message-box">
        âœ¨ å¹³å®‰å¤œå¿«ä¹ï¼âœ¨<br>
        <span style="font-size:0.8em; opacity:0.8;">ä»Šæ™šä¸€èµ·åƒè‹¹æœå—ï¼Ÿ</span>
    </div>

    <div id="status-text">ç­‰å¾…å¯åŠ¨...</div>
    <video id="video-preview" playsinline webkit-playsinline muted autoplay></video>

    <div id="ui-layer">
        <div class="btn-group">
            <button onclick="switchModel('hachiware')" id="btn-hachiware" class="active">å°å…«</button>
            <button onclick="switchModel('usagi')" id="btn-usagi">ä¹Œè¨å¥‡</button>
            <button onclick="switchModel('chiikawa')" id="btn-chiikawa">å‰ä¾å¡å“‡</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { CCDIKSolver, MMDPhysics } from 'three/addons/animation/MMDPhysics.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- æ ¸å¿ƒå˜é‡ ---
        let scene, camera, renderer, controls;
        let particles = [], particleGroup, starMesh;
        let currentModel = null, ikSolver;
        let currentModelName = 'hachiware';
        
        // çŠ¶æ€
        let targetShape = 'random'; 
        let isHandDetected = false;
        let handPosition = new THREE.Vector3(0, 0, 0); 
        let handClenchLevel = 0; // 0=å¼ å¼€, 1=æ¡æ‹³
        
        // å‚æ•°
        const TREE_HEIGHT = 22;
        const TREE_RADIUS = 9;
        const PARTICLE_COUNT = 1200; 

        // æ¨¡å‹æ˜ å°„
        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        // --- 1. å¯åŠ¨é€»è¾‘ (iOS Fix) ---
        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', async () => {
            document.getElementById('start-overlay').style.display = 'none';
            // å¿…é¡»åœ¨ç‚¹å‡»äº‹ä»¶ä¸­åˆå§‹åŒ– AudioContext (å¦‚æœæœ‰) å’Œ Video
            await init();
        });

        async function init() {
            setupScene();
            createParticles();
            createStar(); // åœ£è¯æ ‘é¡¶éƒ¨çš„æ˜Ÿæ˜Ÿ
            loadMMDModel('hachiware');

            // å…¨å±€åˆ‡æ¢
            window.switchModel = (name) => {
                if (currentModelName === name) return;
                currentModelName = name;
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${name}`).classList.add('active');
                loadMMDModel(name);
            };

            await setupMediaPipe();
            animate();
        }

        // --- 2. åœºæ™¯ ---
        function setupScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 20, 20);
            scene.add(dirLight);
        }

        // --- 3. ç²’å­ç³»ç»Ÿ (ç»šä¸½ç‰ˆ) ---
        function createParticles() {
            particleGroup = new THREE.Group();
            scene.add(particleGroup);

            const loader = new THREE.TextureLoader();
            // ä½¿ç”¨ Canvas ç”Ÿæˆè¾‰å…‰è´´å›¾
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // é¢œè‰²å’Œå¤§å°é€»è¾‘
                // é‡‘è‰²: 0xFFD700, ç»¿è‰²: 0x2ED573, çº¢è‰²: 0xFF4757
                let color, size;
                const rand = Math.random();

                if (rand < 0.16) { 
                    // 1/6 çº¢è‰²å¤§ç²’å­
                    color = 0xFF4757; size = 1.2;
                } else if (rand < 0.32) {
                    // 1/6 ç»¿è‰²å¤§ç²’å­
                    color = 0x2ED573; size = 1.2;
                } else {
                    // å‰©ä½™ é‡‘è‰²ç²’å­
                    color = 0xFFD700; size = 0.7;
                }

                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.position.set((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
                sprite.scale.set(size, size, 1);

                // æ ‘å½¢æ€è®¡ç®—
                const yNorm = i / PARTICLE_COUNT; 
                const y = yNorm * TREE_HEIGHT - (TREE_HEIGHT / 2); 
                const r = TREE_RADIUS * (1 - yNorm); // é”¥å½¢
                const angle = i * 0.3; // èºæ—‹å¯†åº¦

                const pData = {
                    mesh: sprite,
                    initialPos: sprite.position.clone(),
                    treePos: new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r),
                    fireworkVel: new THREE.Vector3(),
                    baseScale: size
                };
                particles.push(pData);
                particleGroup.add(sprite);
            }
        }

        function createStar() {
            // åœ£è¯æ ‘é¡¶çš„æ˜Ÿæ˜Ÿ
            const geo = new THREE.OctahedronGeometry(1.5, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xFFFF00, wireframe: true });
            starMesh = new THREE.Mesh(geo, mat);
            starMesh.position.set(0, TREE_HEIGHT/2 + 1, 0);
            starMesh.visible = false;
            scene.add(starMesh);
            
            // å†…éƒ¨å‘å…‰çƒ
            const glowGeo = new THREE.SphereGeometry(0.8);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            starMesh.add(new THREE.Mesh(glowGeo, glowMat));
        }

        // --- 4. æ¨¡å‹åŠ è½½ä¸éª¨éª¼æ§åˆ¶ ---
        function loadMMDModel(name) {
            const path = MODELS[name];
            const loader = new MMDLoader();
            
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }

            loader.load(path, (mesh) => {
                currentModel = mesh;
                mesh.scale.set(1.5, 1.5, 1.5);
                mesh.position.set(12, -10, 0);
                
                // é˜²æ­¢å…¨é»‘
                mesh.material.forEach(mat => {
                    mat.emissive = new THREE.Color(0x333333);
                    if(name === 'usagi') mat.color.setHex(0xFFEEAA);
                    if(name === 'hachiware') mat.color.setHex(0xDDEEFF);
                });

                scene.add(mesh);
            }, undefined, (err) => {
                console.error(err);
                // å¤±è´¥å›é€€
                const geo = new THREE.CapsuleGeometry(2, 4);
                currentModel = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0xffffff}));
                currentModel.position.set(12, -8, 0);
                scene.add(currentModel);
            });
        }

        function updateCharacterBone() {
            if (!currentModel || !currentModel.skeleton) return;

            // MMD éª¨éª¼åç§°é€šå¸¸æ˜¯æ—¥è¯­: å·¦è…• (Left Arm), å³è…• (Right Arm)
            // æ ¹æ®æ¡æ‹³ç¨‹åº¦ (handClenchLevel: 0~1) æ§åˆ¶æ‰‹è‡‚æ—‹è½¬
            // 0(å¼ å¼€): æ‰‹è‡‚æ”¾ä¸‹æˆ–å¼ å¼€
            // 1(æ¡æ‹³): æ‰‹è‡‚å‘å‰åˆæ‹¢ (æŠ±æ ‘åŠ¨ä½œ)

            const skeleton = currentModel.skeleton;
            const bones = skeleton.bones;
            
            // æŸ¥æ‰¾éª¨éª¼ (ç®€å•åç§°åŒ¹é…)
            const armL = bones.find(b => b.name === 'å·¦è…•');
            const armR = bones.find(b => b.name === 'å³è…•');

            if (armL && armR) {
                // ç®€å•çš„æ¬§æ‹‰è§’æ’å€¼
                // åŸå§‹/å¼ å¼€çŠ¶æ€ (Zè½´æ—‹è½¬)
                const openRotZ = -0.8; // å‚ä¸‹/å¼ å¼€
                const closeRotZ = 0.5; // æŠ¬èµ·/å‘å†…

                // å‘å‰æ—‹è½¬ (Xè½´)
                const openRotX = 0;
                const closeRotX = -0.5;

                // è®¡ç®—å½“å‰ç›®æ ‡æ—‹è½¬
                const currentZ_L = THREE.MathUtils.lerp(openRotZ, closeRotZ, handClenchLevel);
                const currentZ_R = THREE.MathUtils.lerp(-openRotZ, -closeRotZ, handClenchLevel); // é•œåƒ
                
                const currentX = THREE.MathUtils.lerp(openRotX, closeRotX, handClenchLevel);

                // åº”ç”¨æ—‹è½¬
                armL.rotation.z = currentZ_L;
                armL.rotation.x = currentX;
                
                armR.rotation.z = currentZ_R;
                armR.rotation.x = currentX;
            }
        }

        // --- 5. AI æ‰‹åŠ¿è¯†åˆ« (å« OK åˆ¤æ–­) ---
        let handLandmarker;
        let lastVideoTime = -1;
        
        async function setupMediaPipe() {
            try {
                document.getElementById('status-text').innerText = "åŠ è½½ AI æ¨¡å‹...";
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                startCamera();
            } catch (e) {
                alert("æ¨¡å‹åŠ è½½å¤±è´¥: " + e);
            }
        }

        async function startCamera() {
            const video = document.getElementById("video-preview");
            try {
                // å¼ºåˆ¶å‰ç½®
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "user", width: 640, height: 480 } 
                });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    video.play();
                    document.getElementById('status-text').innerText = "è¿è¡Œä¸­";
                });
            } catch (err) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ (è¯·ç¡®ä¿ä½¿ç”¨HTTPS): " + err);
            }
        }

        function detectGesture() {
            const video = document.getElementById("video-preview");
            if (!handLandmarker || !video.srcObject) return;

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                const msgBox = document.getElementById('message-box');
                const title = document.getElementById('top-title');

                if (results.landmarks && results.landmarks.length > 0) {
                    isHandDetected = true;
                    const lm = results.landmarks[0];
                    
                    // åæ ‡æ˜ å°„
                    handPosition.set((0.5 - lm[0].x) * 40, (0.5 - lm[0].y) * 30, 10);

                    // 1. è®¡ç®—æ¡æ‹³ç¨‹åº¦ (0~1) ç”¨äºåŠ¨ç”»å¹³æ»‘è¿‡æ¸¡
                    const wrist = lm[0];
                    const tips = [8, 12, 16, 20];
                    let avgDist = 0;
                    tips.forEach(i => {
                        avgDist += Math.sqrt(Math.pow(lm[i].x-wrist.x, 2) + Math.pow(lm[i].y-wrist.y, 2));
                    });
                    avgDist /= 4;
                    
                    // æ˜ å°„è·ç¦»åˆ° 0-1 (0.2=ç´§æ¡, 0.4=å…¨å¼ )
                    // clenchLevel: 1 = Fist, 0 = Open
                    let rawClench = THREE.MathUtils.mapLinear(avgDist, 0.4, 0.2, 0, 1);
                    rawClench = THREE.MathUtils.clamp(rawClench, 0, 1);
                    // å¹³æ»‘å¤„ç†
                    handClenchLevel += (rawClench - handClenchLevel) * 0.1;

                    // 2. çŠ¶æ€åˆ¤æ–­
                    if (handClenchLevel > 0.7) {
                        targetShape = 'tree';
                        msgBox.style.display = 'none';
                    } else if (handClenchLevel < 0.3) {
                        targetShape = 'firework';
                        msgBox.style.display = 'none';
                    }

                    // 3. OK æ‰‹åŠ¿åˆ¤å®š
                    // é€»è¾‘: æ‹‡æŒ‡å°–(4)ä¸é£ŸæŒ‡å°–(8)è·ç¦»å¾ˆè¿‘ï¼Œä¸”ä¸­æŒ‡(12)ä¼¸ç›´(ç¦»æŒå¿ƒè¿œ)
                    const thumbTip = lm[4];
                    const indexTip = lm[8];
                    const middleTip = lm[12];
                    
                    const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                    const middleDist = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));

                    // é˜ˆå€¼: æåˆ<0.05 ä¸” ä¸­æŒ‡ä¼¸å±•>0.3
                    if (pinchDist < 0.06 && middleDist > 0.3) {
                        targetShape = 'random'; // æš‚åœå…¶ä»–ç‰¹æ•ˆ
                        msgBox.style.display = 'block'; // æ˜¾ç¤ºæ–‡å­—æ¡†
                        title.style.opacity = 0.2; // æ ‡é¢˜å˜æ·¡
                    } else {
                        // åªæœ‰åœ¨éOKçŠ¶æ€æ‰æ¢å¤æ ‡é¢˜
                        title.style.opacity = 1;
                    }

                } else {
                    isHandDetected = false;
                    handClenchLevel = 0; // æ— æ‰‹æ—¶é»˜è®¤å¼ å¼€
                    targetShape = 'random';
                }
            }
        }

        // --- 6. åŠ¨ç”» ---
        function animate() {
            requestAnimationFrame(animate);
            detectGesture();
            
            const time = Date.now() * 0.001;

            // ç²’å­åŠ¨ç”»
            particles.forEach(p => {
                const current = p.mesh.position;
                
                // æ˜Ÿæ˜Ÿæ˜¾ç¤ºé€»è¾‘
                if (starMesh) {
                    starMesh.visible = (targetShape === 'tree' && handClenchLevel > 0.8);
                    starMesh.rotation.y += 0.05;
                    // è®©æ˜Ÿæ˜Ÿè·Ÿéšæ ‘é¡¶æ™ƒåŠ¨
                    starMesh.position.y = TREE_HEIGHT/2 + 3 + Math.sin(time*3)*0.5;
                }

                if (targetShape === 'tree') {
                    // æ¡æ‹³: èšæ‹¢
                    current.lerp(p.treePos, 0.08);
                    // æ ‘æ•´ä½“æ—‹è½¬ + èºæ—‹
                    const spin = 0.5 * time; 
                    const x = p.treePos.x * Math.cos(spin) - p.treePos.z * Math.sin(spin);
                    const z = p.treePos.x * Math.sin(spin) + p.treePos.z * Math.cos(spin);
                    // å åŠ  current çš„ lerpï¼Œè¿™é‡Œç®€å•å¤„ç†ï¼Œå®é™…ä¸Šåº”è¯¥lerpåˆ°åŠ¨æ€çš„treePos
                    // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬åªåšå¾®è°ƒ
                    p.mesh.position.y += Math.sin(time * 3 + current.x) * 0.02;
                    
                } else if (targetShape === 'firework') {
                    // å¼ æ‰‹: çƒŸèŠ±
                    if (p.fireworkVel.lengthSq() === 0) {
                        p.fireworkVel.copy(current).normalize().multiplyScalar(Math.random()*0.8 + 0.3);
                        p.fireworkVel.y += 0.15;
                    }
                    current.add(p.fireworkVel);
                    p.fireworkVel.y -= 0.01;
                    p.mesh.material.opacity -= 0.02;
                    if (p.mesh.material.opacity <= 0) {
                        p.mesh.position.set(0,0,0);
                        p.mesh.material.opacity = 1;
                        p.fireworkVel.set(0,0,0);
                    }
                } else {
                    // é»˜è®¤/OKçŠ¶æ€
                    current.y += Math.sin(time + current.x) * 0.02;
                    current.lerp(p.initialPos, 0.05);
                    p.mesh.material.opacity = 1;
                    p.fireworkVel.set(0,0,0);
                }
            });

            // äººç‰©åŠ¨ç”»
            if (currentModel) {
                // æ‰‹è‡‚åŠ¨ä½œ (åŸºäº handClenchLevel)
                updateCharacterBone();

                // å¤´éƒ¨è·Ÿéš
                if (isHandDetected) {
                    const lookPos = handPosition.clone();
                    lookPos.x += 12; 
                    currentModel.lookAt(lookPos);
                } else {
                    currentModel.rotation.set(0,0,0);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ç­‰å¾…ç”¨æˆ·ç‚¹å‡» "å¼€å§‹" æŒ‰é’®è§¦å‘ init()
    </script>
</body>
</html>
