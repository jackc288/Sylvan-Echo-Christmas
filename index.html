<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Christmas Magic 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; font-family: "Helvetica Neue", sans-serif; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* 1. é¡¶éƒ¨è‰ºæœ¯å­— */
        #top-title {
            position: absolute; top: 8vh; width: 100%; text-align: center;
            font-family: 'Times New Roman', serif; font-size: 2.2rem; font-weight: bold;
            background: linear-gradient(to right, #dff9fb, #ffffff, #f1f2f6);
            -webkit-background-clip: text; color: transparent;
            text-shadow: 0 0 15px rgba(255,255,255,0.6);
            z-index: 10; pointer-events: none;
            transition: opacity 0.5s;
        }

        /* 2. å¯åŠ¨é®ç½© */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; transition: opacity 0.5s;
        }
        #loading-text { margin-bottom: 20px; color: #aaa; font-size: 14px; }
        #start-btn {
            padding: 15px 50px; font-size: 1.2rem; background: #333; border: 1px solid #555;
            border-radius: 30px; color: #888; cursor: not-allowed; transition: 0.3s;
        }
        #start-btn.ready {
            background: #e55039; color: white; border-color: #e55039;
            box-shadow: 0 0 25px rgba(229, 80, 57, 0.6); animation: pulse 1.5s infinite; cursor: pointer;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* 3. ç¥ç¦å¼¹çª— */
        #message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 320px; padding: 25px;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 20px;
            color: #fff; font-size: 1.3rem; text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0, 0.5);
            display: none; z-index: 30;
        }

        /* 4. åº•éƒ¨æŒ‰é’® */
        #ui-layer {
            position: absolute; bottom: 40px; left: 0; width: 100%;
            text-align: center; z-index: 10; pointer-events: none;
        }
        .btn-group {
            pointer-events: auto; background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px); padding: 8px; border-radius: 25px;
            display: inline-block; border: 1px solid rgba(255,255,255,0.1);
        }
        button.model-btn {
            background: transparent; color: rgba(255,255,255,0.7);
            border: none; padding: 10px 20px; margin: 0;
            border-radius: 20px; font-size: 14px; transition: 0.3s;
        }
        button.model-btn.active { background: rgba(255,255,255,0.2); color: white; font-weight: bold; }

        /* 5. éšè—è§†é¢‘ */
        #video-preview {
            position: absolute; top: 0; left: 0; width: 1px; height: 1px;
            opacity: 0.01; pointer-events: none; transform: scaleX(-1);
        }
        #debug { position: absolute; top: 5px; left: 5px; color: #555; font-size: 10px; z-index: 5; }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-family: serif; font-size: 2.5rem; color: #f1f2f6;">Christmas<br>Dream</h1>
        <div id="loading-text">èµ„æºåˆå§‹åŒ–ä¸­...</div>
        <button id="start-btn" disabled>åŠ è½½ä¸­</button>
    </div>

    <div id="top-title">mm, Happy Christmas</div>
    <div id="debug">v3.0</div>
    
    <div id="message-box">
        ğŸ„ Merry Christmas ğŸ„<br>
        <div style="font-size: 0.9rem; color: #ccc; margin-top: 10px; line-height: 1.5;">
            æ„¿ä½ çš„ä¸–ç•Œ<br>å¦‚æ˜Ÿå…‰èˆ¬ç’€ç’¨
        </div>
    </div>

    <video id="video-preview" playsinline webkit-playsinline muted autoplay></video>

    <div id="ui-layer">
        <div class="btn-group">
            <button onclick="switchModel('hachiware')" id="btn-hachiware" class="model-btn active">å°å…«</button>
            <button onclick="switchModel('usagi')" id="btn-usagi" class="model-btn">ä¹Œè¨å¥‡</button>
            <button onclick="switchModel('chiikawa')" id="btn-chiikawa" class="model-btn">å‰ä¾å¡å“‡</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, controls;
        let ornaments = []; // åœ£è¯æ ‘ä¸»ä½“æ–¹å—æ•°ç»„
        let flowParticles = []; // å¤–å›´æµå…‰ç²’å­
        let starMesh; // é¡¶éƒ¨äº”è§’æ˜Ÿ
        let currentModel = null, currentModelName = 'hachiware';
        
        // äº¤äº’çŠ¶æ€
        let targetShape = 'random'; 
        let handClenchLevel = 0; // 0=å¼ å¼€, 1=æ¡æ‹³
        let isHandDetected = false;
        let sceneRotationVelocity = 0;
        let previousHandX = 0;

        // å‚æ•°é…ç½®
        const TREE_HEIGHT = 24;
        const TREE_RADIUS = 10;
        const ORNAMENT_COUNT = 800; // ç§¯æœ¨æ•°é‡
        const FLOW_COUNT = 300; // æµå…‰æ•°é‡

        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        const startBtn = document.getElementById('start-btn');
        const loadingText = document.getElementById('loading-text');

        // --- 1. åˆå§‹åŒ–å…¥å£ ---
        init3D();
        preloadAI();

        startBtn.addEventListener('click', async () => {
            if (startBtn.disabled) return;
            startBtn.innerText = "å¯åŠ¨è§†è§‰...";
            try {
                await startCamera();
                document.getElementById('start-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
                animate();
            } catch (e) {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e);
            }
        });

        // --- 2. åœºæ™¯æ„å»º ---
        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.02); // æ·±è‰²é›¾
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 6, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;

            // ç¯å…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 20);
            scene.add(dirLight);
            
            // èšå…‰ç¯ç»™æ ‘æ‰“å…‰
            const spotLight = new THREE.SpotLight(0xffaa00, 200);
            spotLight.position.set(0, 30, 10);
            spotLight.angle = 0.5;
            spotLight.penumbra = 0.5;
            scene.add(spotLight);

            createBlockTree(); // åˆ›å»ºæ–¹å—æ ‘
            createFlowParticles(); // åˆ›å»ºæµå…‰
            create3DStar(); // åˆ›å»º3Dæ˜Ÿæ˜Ÿ
            loadMMDModel('hachiware');

            // åˆ‡æ¢æ¨¡å‹
            window.switchModel = (name) => {
                if (currentModelName === name) return;
                currentModelName = name;
                document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${name}`).classList.add('active');
                loadMMDModel(name);
            };
        }

        // --- 3. åœ£è¯æ ‘ä¸»ä½“ (å‡ ä½•å—) ---
        function createBlockTree() {
            // å‡†å¤‡å‡ ä½•ä½“
            const geoCube = new THREE.BoxGeometry(1, 1, 1);
            const geoTetra = new THREE.TetrahedronGeometry(0.7);
            const geoSphere = new THREE.SphereGeometry(0.6, 16, 16);
            
            // å‡†å¤‡æè´¨
            const matDarkGreen = new THREE.MeshStandardMaterial({ color: 0x0f3b18, roughness: 0.3 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xb33939, roughness: 0.2 });
            const matGrey = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.4 });
            
            // æ©˜è‰²å¸¦é‡‘ç‚¹æè´¨ (Canvasç”Ÿæˆ)
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#ff9f43'; ctx.fillRect(0,0,64,64); // æ©˜è‰²åº•
            ctx.fillStyle = '#feca57'; // é‡‘ç‚¹
            // ç”»5ä¸ªç‚¹
            [[32,32], [16,16], [48,16], [16,48], [48,48]].forEach(pos => {
                ctx.beginPath(); ctx.arc(pos[0], pos[1], 4, 0, Math.PI*2); ctx.fill();
            });
            const texOrange = new THREE.CanvasTexture(cvs);
            const matOrange = new THREE.MeshStandardMaterial({ map: texOrange, roughness: 0.3 });

            // ç”Ÿæˆè£…é¥°å—
            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                let mesh, type;
                const r = Math.random();

                // å‡åŒ€åˆ†é…ç±»å‹
                if (r < 0.2) { // æš—ç»¿æ­£æ–¹ä½“
                    mesh = new THREE.Mesh(geoCube, matDarkGreen); type = 'green_cube';
                } else if (r < 0.4) { // æš—ç»¿ä¸‰è§’
                    mesh = new THREE.Mesh(geoTetra, matDarkGreen); type = 'green_tri';
                } else if (r < 0.6) { // çº¢è‰²ä¸‰è§’
                    mesh = new THREE.Mesh(geoTetra, matRed); type = 'red_tri';
                } else if (r < 0.75) { // çº¢è‰²çƒ
                    mesh = new THREE.Mesh(geoSphere, matRed); type = 'red_sphere';
                } else if (r < 0.88) { // ç°è‰²æ­£æ–¹ä½“ (ä¼šé—ª)
                    // ç°è‰²æ­£æ–¹ä½“éœ€è¦ç‹¬ç«‹çš„æè´¨å®ä¾‹ï¼Œå› ä¸ºè¦å•ç‹¬æ§åˆ¶å‘å…‰
                    const matFlash = matGrey.clone();
                    mesh = new THREE.Mesh(geoCube, matFlash); type = 'grey_flash';
                } else { // æ©˜è‰²é‡‘ç‚¹çƒ
                    mesh = new THREE.Mesh(geoSphere, matOrange); type = 'orange_sphere';
                }

                // åˆå§‹æ•£å¼€ä½ç½®
                const spreadRange = 50;
                mesh.position.set(
                    (Math.random()-0.5) * spreadRange,
                    (Math.random()-0.5) * spreadRange,
                    (Math.random()-0.5) * spreadRange
                );
                
                // æ ‘å½¢æ€çš„ç›®æ ‡ä½ç½® (èºæ—‹é”¥ä½“)
                const yNorm = i / ORNAMENT_COUNT; 
                const y = yNorm * TREE_HEIGHT - (TREE_HEIGHT / 2); 
                const radius = TREE_RADIUS * (1 - yNorm); 
                const angle = i * 0.4; // ç´§å¯†çš„èºæ—‹

                scene.add(mesh);
                
                ornaments.push({
                    mesh: mesh,
                    type: type,
                    initialPos: mesh.position.clone(), // éšæœºæ¸¸è¡çš„åŸºå‡†ç‚¹
                    treePos: new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius),
                    velocity: new THREE.Vector3() // çˆ†ç‚¸é€Ÿåº¦
                });
            }
        }

        // --- 4. å¤–å±‚æµå…‰ç²’å­ ---
        function createFlowParticles() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(FLOW_COUNT * 3);
            const speeds = new Float32Array(FLOW_COUNT);
            const offsets = new Float32Array(FLOW_COUNT);

            for (let i = 0; i < FLOW_COUNT; i++) {
                // åˆå§‹éƒ½åœ¨åº•éƒ¨é™„è¿‘
                pos[i*3] = (Math.random()-0.5) * TREE_RADIUS * 2;
                pos[i*3+1] = -TREE_HEIGHT/2 + Math.random() * TREE_HEIGHT;
                pos[i*3+2] = (Math.random()-0.5) * TREE_RADIUS * 2;
                speeds[i] = 0.05 + Math.random() * 0.1; // ä¸Šå‡é€Ÿåº¦
                offsets[i] = Math.random() * Math.PI * 2; // è§’åº¦åç§»
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            // äº®ç™½è‰²å‘å…‰æè´¨
            const mat = new THREE.PointsMaterial({
                color: 0xffffff, size: 0.4, transparent: true, opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            const points = new THREE.Points(geo, mat);
            scene.add(points);
            
            flowParticles = { mesh: points, speeds: speeds, offsets: offsets };
        }

        // --- 5. 3D äº”è§’æ˜Ÿ ---
        function create3DStar() {
            const shape = new THREE.Shape();
            const outer = 1.2, inner = 0.5;
            for (let i=0; i<10; i++) {
                const rad = i * Math.PI * 0.2; // 36åº¦
                const len = (i%2===0) ? outer : inner;
                const x = Math.cos(rad) * len;
                const y = Math.sin(rad) * len;
                if(i===0) shape.moveTo(x, y); else shape.lineTo(x, y);
            }
            shape.closePath();

            const extrudeSettings = { depth: 0.5, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 1.0, roughness: 0.1 
            });
            
            starMesh = new THREE.Mesh(geometry, material);
            starMesh.position.set(0, TREE_HEIGHT/2 + 1.5, 0);
            starMesh.visible = false;
            scene.add(starMesh);
        }

        // --- 6. é€»è¾‘ä¸åŠ¨ç”» ---
        let handLandmarker;
        async function preloadAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                startBtn.disabled = false; startBtn.classList.add('ready'); startBtn.innerText = "ç‚¹å‡»å¼€å¯é­”æ³•";
                loadingText.innerText = "èµ„æºå°±ç»ª";
            } catch (e) {
                loadingText.innerText = "AI åŠ è½½å¤±è´¥";
            }
        }

        async function startCamera() {
            const video = document.getElementById("video-preview");
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 640, height: 480 } });
            video.srcObject = stream;
            return new Promise(r => video.onloadeddata = () => { video.play(); r(); });
        }

        function loadMMDModel(name) {
            new MMDLoader().load(MODELS[name], (mesh) => {
                if (currentModel) scene.remove(currentModel);
                currentModel = mesh;
                mesh.scale.set(1.5, 1.5, 1.5);
                // å›ºå®šä½ç½®ï¼Œæ°¸è¿œä¸åŠ¨
                mesh.position.set(12, -10, 0); 
                mesh.rotation.set(0, 0, 0); // åˆå§‹è§’åº¦å½’é›¶

                mesh.material.forEach(m => {
                    m.emissive = new THREE.Color(0x333333);
                    if(name==='usagi') m.color.setHex(0xFFEEAA);
                    if(name==='hachiware') m.color.setHex(0xDDEEFF);
                });
                scene.add(mesh);
            });
        }

        let lastVideoTime = -1;
        function updateLogic() {
            const video = document.getElementById("video-preview");
            if (!handLandmarker || !video || video.paused) return;

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const res = handLandmarker.detectForVideo(video, performance.now());
                const msgBox = document.getElementById('message-box');
                const title = document.getElementById('top-title');

                if (res.landmarks && res.landmarks.length > 0) {
                    isHandDetected = true;
                    const lm = res.landmarks[0];
                    const wrist = lm[0];
                    
                    // è®¡ç®—æ¡æ‹³åº¦
                    const tips = [8,12,16,20];
                    let dist = 0;
                    tips.forEach(i => dist += Math.sqrt(Math.pow(lm[i].x-wrist.x,2) + Math.pow(lm[i].y-wrist.y,2)));
                    dist /= 4;
                    let rawClench = THREE.MathUtils.mapLinear(dist, 0.45, 0.2, 0, 1);
                    handClenchLevel += (THREE.MathUtils.clamp(rawClench, 0, 1) - handClenchLevel) * 0.15;

                    // çŠ¶æ€æœº
                    if (handClenchLevel > 0.7) targetShape = 'tree';
                    else if (handClenchLevel < 0.3) targetShape = 'firework';

                    // æ‰‡åŠ¨æ£€æµ‹ (åªæœ‰åœ¨å¼ æ‰‹/çƒŸèŠ±æ¨¡å¼ä¸‹)
                    const rawX = 0.5 - wrist.x;
                    if (targetShape === 'firework') {
                         const delta = rawX - previousHandX;
                         if (Math.abs(delta) > 0.01) sceneRotationVelocity += delta * 2.0;
                    }
                    previousHandX = rawX;

                    // OK æ‰‹åŠ¿
                    const pinch = Math.sqrt(Math.pow(lm[4].x-lm[8].x,2) + Math.pow(lm[4].y-lm[8].y,2));
                    const middle = Math.sqrt(Math.pow(lm[12].x-wrist.x,2) + Math.pow(lm[12].y-wrist.y,2));
                    if (pinch < 0.06 && middle > 0.25) {
                        msgBox.style.display = 'block'; title.style.opacity = 0;
                    } else {
                        msgBox.style.display = 'none'; title.style.opacity = 1;
                    }
                } else {
                    isHandDetected = false;
                    handClenchLevel = 0;
                    targetShape = 'random';
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateLogic();
            
            const time = Date.now() * 0.001;
            const dt = 0.016;

            // 1. åœºæ™¯æ‰‡åŠ¨æ—‹è½¬
            if (Math.abs(sceneRotationVelocity) > 0.001) {
                scene.rotation.y += sceneRotationVelocity;
                sceneRotationVelocity *= 0.95; 
            } else {
                scene.rotation.y += 0.002; // è‡ªåŠ¨æ—‹è½¬
            }

            // 2. åœ£è¯æ ‘æ–¹å—é€»è¾‘
            const isTree = (targetShape === 'tree');
            
            // æ˜Ÿæ˜Ÿæ˜¾éš
            if (starMesh) {
                starMesh.visible = (isTree && handClenchLevel > 0.8);
                if (starMesh.visible) {
                    starMesh.rotation.y += 0.02;
                    starMesh.rotation.z = Math.sin(time) * 0.1;
                }
            }

            ornaments.forEach(p => {
                const cur = p.mesh.position;

                // é—ªå…‰é€»è¾‘: ç°è‰²æ–¹å—æ¯0.75ç§’é—ªä¸€æ¬¡
                if (p.type === 'grey_flash') {
                    // æ—¶é—´å–æ¨¡ï¼Œ0.1ç§’çš„äº®ç¯çª—å£
                    const flash = (time % 0.75 < 0.1);
                    p.mesh.material.emissive.setHex(flash ? 0xffffff : 0x000000);
                    p.mesh.material.emissiveIntensity = flash ? 2.0 : 0;
                }

                if (isTree) {
                    // æ¡æ‹³: é£å‘æ ‘çš„ä½ç½®
                    cur.lerp(p.treePos, 0.1);
                    p.mesh.rotation.x += 0.01; 
                    p.mesh.rotation.y += 0.01;
                    // å½’é›¶é€Ÿåº¦
                    p.velocity.set(0,0,0);
                } else if (targetShape === 'firework') {
                    // å¼ æ‰‹: çˆ†ç‚¸æ•£å¼€ (Scatter)
                    if (p.velocity.lengthSq() < 0.001) {
                        // è®¡ç®—ä»ä¸­å¿ƒå‘å¤–çš„å‘é‡
                        // å‡è®¾ä¸­å¿ƒæ˜¯ (0, 0, 0) æˆ–è€…æ ‘çš„ä¸­å¿ƒ (0, 0, 0)
                        // è®©å®ƒæ²¿ç€ç›®å‰çš„ä½ç½®å‘å¤–é£ï¼Œå¹¶ç¨å¾®å¸¦ç‚¹å‘ä¸Š
                        const dir = cur.clone().normalize(); 
                        if (dir.lengthSq()===0) dir.set(0,1,0); // é˜²æ­¢åŸç‚¹
                        
                        const speed = Math.random() * 0.5 + 0.2;
                        p.velocity.copy(dir).multiplyScalar(speed);
                    }
                    
                    cur.add(p.velocity);
                    p.velocity.multiplyScalar(0.98); // ç©ºæ°”é˜»åŠ›
                    
                } else {
                    // éšæœºæ‚¬æµ®
                    cur.lerp(p.initialPos, 0.05);
                    cur.y += Math.sin(time + cur.x)*0.01;
                }
            });

            // 3. æµå…‰ç²’å­é€»è¾‘ (æ°¸è¿œå‘ä¸ŠæµåŠ¨)
            if (flowParticles.mesh) {
                const pos = flowParticles.mesh.geometry.attributes.position.array;
                for(let i=0; i<FLOW_COUNT; i++) {
                    const idx = i*3;
                    // Yè½´ä¸Šå‡
                    pos[idx+1] += flowParticles.speeds[i];
                    
                    // èºæ—‹è¿åŠ¨
                    const angle = time * 0.5 + flowParticles.offsets[i];
                    // éšç€é«˜åº¦å¢åŠ ï¼ŒåŠå¾„ç¨å¾®æ”¶ç¼©(æ¨¡ä»¿æ ‘å½¢)
                    // yèŒƒå›´å¤§è‡´ -12 åˆ° 12
                    const normalizedY = (pos[idx+1] + TREE_HEIGHT/2) / TREE_HEIGHT; 
                    const r = TREE_RADIUS * 1.5 * (1 - normalizedY * 0.6); // å¤–å›´ç¯ç»•
                    
                    pos[idx] = Math.cos(angle) * r;
                    pos[idx+2] = Math.sin(angle) * r;

                    // å¾ªç¯é‡ç½®
                    if (pos[idx+1] > TREE_HEIGHT/2 + 2) {
                        pos[idx+1] = -TREE_HEIGHT/2 - 2;
                    }
                }
                flowParticles.mesh.geometry.attributes.position.needsUpdate = true;
                // åªæœ‰å˜æˆæ ‘çš„æ—¶å€™æ‰æ˜¾ç¤ºå¤–å±‚æµå…‰ï¼Œæˆ–è€…ä¸€ç›´æ˜¾ç¤ºï¼Ÿç”¨æˆ·è¯´"æºæºä¸æ–­"ï¼Œå»ºè®®ä¸€ç›´æ˜¾ç¤ºæ›´æœ‰æ°›å›´
                flowParticles.mesh.visible = isTree; 
            }

            // 4. äººç‰©æ‰‹è‡‚æ§åˆ¶ (Only Arms)
            if (currentModel && currentModel.skeleton) {
                const bones = currentModel.skeleton.bones;
                const armL = bones.find(b => b.name === 'å·¦è…•');
                const armR = bones.find(b => b.name === 'å³è…•');
                
                if (armL && armR) {
                    // æ’å€¼è®¡ç®—è§’åº¦
                    const z = THREE.MathUtils.lerp(-0.8, 0.6, handClenchLevel); // å¼ å¼€(-0.8) -> æŠ±ä½(0.6)
                    const x = THREE.MathUtils.lerp(0, -0.6, handClenchLevel);   // å‰ä¼¸
                    
                    armL.rotation.z = z; armL.rotation.x = x;
                    armR.rotation.z = -z; armR.rotation.x = x;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
