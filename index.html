<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sylvan Echo Christmas</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #2a162b 0%, #000000 100%); /* æ·±ç´«è‰²å¤œç©º */
            font-family: 'Cinzel', serif;
            user-select: none; -webkit-user-select: none;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ */
        #top-title {
            position: absolute; top: 5%; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }
        #top-title h1 {
            font-family: 'Great Vibes', cursive; font-size: 3rem; color: #ffdae0; margin: 0;
            text-shadow: 0 0 15px rgba(255, 182, 193, 0.8), 0 0 30px rgba(255, 105, 180, 0.5);
            animation: breathe 4s infinite ease-in-out;
        }
        @keyframes breathe { 50% { opacity: 0.8; text-shadow: 0 0 25px rgba(255, 105, 180, 0.9); } }

        /* åŒæ‰‹çˆ±å¿ƒè§¦å‘çš„æ–‡æœ¬æ¡† */
        #custom-message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.5); border-radius: 20px;
            padding: 30px 50px; text-align: center; color: #fff;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.4);
            display: none; z-index: 50; animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #custom-message-box p { font-size: 1.5rem; margin: 0; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #camera-preview {
            position: absolute; bottom: 20px; left: 20px; width: 200px; height: 150px;
            border: 2px solid rgba(255, 192, 203, 0.4); border-radius: 12px;
            background: rgba(0,0,0,0.5); transform: scaleX(-1); object-fit: cover; z-index: 20;
        }

        /* ä¾§è¾¹æ‰‹åŠ¿æŒ‡å— */
        #gesture-guide {
            position: absolute; top: 20%; right: 20px; width: 200px;
            background: rgba(0,0,0,0.6); padding: 20px; border-radius: 12px;
            border-left: 4px solid #ff69b4; color: #ddd; font-size: 0.9rem; z-index: 15;
            pointer-events: none;
        }
        .g-item { margin-bottom: 12px; opacity: 0.5; transition: 0.3s; display: flex; align-items: center; }
        .g-item.active { opacity: 1; color: #fff; font-weight: bold; text-shadow: 0 0 8px #ff69b4; transform: translateX(-5px); }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; align-items: center; z-index: 20;
            background: rgba(20, 20, 30, 0.6); padding: 10px 25px; border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(8px);
        }
        .btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white;
            padding: 8px 18px; border-radius: 20px; cursor: pointer; font-family: 'Cinzel', serif;
            transition: 0.3s; white-space: nowrap;
        }
        .btn:hover, .btn.active { background: #ff69b4; border-color: #ff69b4; color: #000; box-shadow: 0 0 15px #ff69b4; }
        #file-input { display: none; }

        /* åŠ è½½é¡µ */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffdae0;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid #333; border-top: 3px solid #ff69b4;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">Loading AI Magic...</div>
        <button id="start-btn" class="btn" style="display:none; margin-top:20px;">å¼€å¯ä½“éªŒ</button>
    </div>

    <div id="top-title"><h1>Sylvan Echo, Happy Christmas</h1></div>

    <div id="custom-message-box">
        <p>âœ¨ æ„¿æ˜Ÿå…‰æŒ‡å¼•ä½  âœ¨<br>Sylvan Echo</p>
    </div>

    <video id="camera-preview" playsinline muted autoplay></video>

    <div id="gesture-guide">
        <div class="g-item" id="g-tree">ğŸ– æ— æ‰‹åŠ¿: åœ£è¯æ ‘</div>
        <div class="g-item" id="g-fist">âœŠ å•æ‰‹æ‹³: "mm"çˆ±å¿ƒ</div>
        <div class="g-item" id="g-burst">ğŸ– å•æ‰‹å¼ : çƒŸèŠ±</div>
        <div class="g-item" id="g-pinch">ğŸ‘Œ æåˆ: æ”¾å¤§ç…§ç‰‡</div>
        <div class="g-item" id="g-love">ğŸ«¶ åŒæ‰‹: å¬å”¤ç¥ç¦</div>
    </div>

    <div id="controls">
        <button class="btn" onclick="document.getElementById('file-input').click()">ğŸ“· ä¸Šä¼ ç…§ç‰‡</button>
        <input type="file" id="file-input" accept="image/*" multiple>
        
        <button class="btn" id="music-btn">ğŸµ éŸ³ä¹</button>
        <div style="width:1px; height:20px; background:rgba(255,255,255,0.3);"></div>
        <button class="btn active" onclick="switchModel('hachiware')">å°å…«</button>
        <button class="btn" onclick="switchModel('usagi')">ä¹Œè¨å¥‡</button>
        <button class="btn" onclick="switchModel('chiikawa')">å‰ä¾å¡å“‡</button>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- æ ¸å¿ƒå˜é‡ ---
        let scene, camera, renderer, composer, controls;
        let particles, particleGeo;
        let photoMeshGroup = new THREE.Group();
        let snowSystem;
        let orionStars = []; // çŒæˆ·åº§æ˜Ÿæ˜Ÿå¼•ç”¨
        let mmTextSprite;

        // æ¨¡å‹ç›¸å…³
        let currentModel = null;
        let modelBones = { leftArm: null, rightArm: null };
        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        // çŠ¶æ€
        let state = 'tree'; // tree, heart, firework, pinch, love
        let handClench = 0; // 0=open, 1=fist
        let pinchFocusPhoto = null; // å½“å‰è¢«æåˆæ”¾å¤§çš„ç…§ç‰‡
        let isMusicPlaying = false;
        let clock = new THREE.Clock();

        // ç²’å­å‚æ•°
        const P_COUNT = 1500;
        const TREE_H = 25;
        const TREE_R = 10;
        const positions = [], colors = [];
        const targetTree = [], targetHeart = [];
        const velocities = [];

        // éŸ³é¢‘ä¸Šä¸‹æ–‡
        let audioCtx, oscillator, musicTimer;

        // --- åˆå§‹åŒ–æµç¨‹ ---
        window.onload = async () => {
            await initAI();
            document.getElementById('loading-text').innerText = "Resource Ready";
            document.getElementById('start-btn').style.display = 'block';
        };

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
            initThree();
            initAudioSystem();
            startCamera();
            loadModel('hachiware'); // é»˜è®¤åŠ è½½å°å…«
            animate();
        });

        // --- 1. Three.js åœºæ™¯ ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x2a162b, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // åå¤„ç† (è¾‰å…‰)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; 
            bloomPass.strength = 1.5; 
            bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // ç¯å…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dl = new THREE.DirectionalLight(0xffd700, 1.2);
            dl.position.set(10, 20, 20);
            scene.add(dl);

            // æ„å»ºåœºæ™¯å…ƒç´ 
            createOrion();
            createBackgroundStars();
            createParticles();
            createSnow();
            createMMText();
            scene.add(photoMeshGroup); // ç…§ç‰‡ç»„

            // ç›‘å¬çª—å£
            window.addEventListener('resize', onWindowResize);
        }

        // --- 2. çœŸå®çŒæˆ·åº§ (Orion) ---
        function createOrion() {
            const orionGroup = new THREE.Group();
            // ç›¸å¯¹åæ ‡ (åŸºäºçœŸå®æ˜Ÿå›¾å¤§è‡´æ¯”ä¾‹)
            // å‚å®¿å›› (Betelgeuse): å·¦è‚©, çº¢è¶…å·¨æ˜Ÿ
            // å‚å®¿ä¸ƒ (Rigel): å³è„š, è“è¶…å·¨æ˜Ÿ
            // å‚å®¿äº” (Bellatrix): å³è‚©
            // å‚å®¿å…­ (Saiph): å·¦è„š
            // å‚å®¿ä¸€, äºŒ, ä¸‰ (è…°å¸¦)
            const starsData = [
                { pos: [-3, 4, 0], color: 0xFF4500, size: 0.6 }, // Betelgeuse (Red)
                { pos: [3, 2, 0], color: 0x87CEEB, size: 0.5 },  // Bellatrix (Blue-ish)
                { pos: [-0.5, 0, 0], color: 0xFFFFFF, size: 0.4 }, // Alnilam (Belt)
                { pos: [1, 0.5, 0], color: 0xFFFFFF, size: 0.4 },  // Mintaka (Belt)
                { pos: [-2, -0.5, 0], color: 0xFFFFFF, size: 0.4 }, // Alnitak (Belt)
                { pos: [-2, -5, 0], color: 0x87CEEB, size: 0.5 },  // Saiph
                { pos: [4, -4, 0], color: 0xA0D6FF, size: 0.7 }    // Rigel (Bright Blue)
            ];

            const geo = new THREE.SphereGeometry(1, 8, 8);
            starsData.forEach(s => {
                const mat = new THREE.MeshBasicMaterial({ color: s.color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(s.pos[0], s.pos[1], s.pos[2]);
                mesh.scale.setScalar(s.size);
                mesh.userData.baseScale = s.size; // ç”¨äºé—ªçƒè®¡ç®—
                mesh.userData.randomPhase = Math.random() * 10;
                orionStars.push(mesh);
                orionGroup.add(mesh);
            });

            // æ”¾åœ¨å·¦è¾¹æ˜¾çœ¼ä½ç½®
            orionGroup.position.set(-35, 15, -20);
            orionGroup.scale.set(1.5, 1.5, 1.5);
            scene.add(orionGroup);
        }

        // æ™®é€šèƒŒæ™¯æ˜Ÿç©º
        function createBackgroundStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) {
                pos.push((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*100 - 50);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0xffffff, size:0.3, transparent:true, opacity:0.6});
            scene.add(new THREE.Points(geo, mat));
        }

        // --- 3. ç²’å­ç³»ç»Ÿ (æ ‘ & çˆ±å¿ƒ) ---
        function createParticles() {
            const geo = new THREE.BufferGeometry();
            const color1 = new THREE.Color(0xD4AF37); // é‡‘
            const color2 = new THREE.Color(0xFF69B4); // ç²‰

            for(let i=0; i<P_COUNT; i++) {
                // åˆå§‹ä½ç½®
                positions.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
                velocities.push(0,0,0);
                
                // é¢œè‰²
                const c = color1.clone().lerp(color2, Math.random());
                colors.push(c.r, c.g, c.b);

                // Tree Target (Conical Spiral)
                const yNorm = i / P_COUNT;
                const y = yNorm * TREE_H - TREE_H/2;
                const r = TREE_R * (1 - yNorm);
                const angle = i * 0.2;
                targetTree.push(Math.cos(angle)*r, y, Math.sin(angle)*r);

                // Heart Target (Parametric)
                const t = Math.random() * Math.PI * 2; // 0 to 2PI
                const scale = 0.8;
                // Extended heart formula for volume
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const hz = (Math.random()-0.5) * 6; // Thickness
                targetHeart.push(hx * scale, hy * scale + 5, hz * scale);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            // è‡ªå®šä¹‰å±æ€§å­˜å‚¨ç›®æ ‡ä½ç½®
            geo.setAttribute('targetTree', new THREE.Float32BufferAttribute(targetTree, 3));
            geo.setAttribute('targetHeart', new THREE.Float32BufferAttribute(targetHeart, 3));
            geo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const mat = new THREE.PointsMaterial({
                size: 0.5, vertexColors: true, blending: THREE.AdditiveBlending,
                depthWrite: false, map: createGlowTexture()
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        function createGlowTexture() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<500; i++) pos.push((Math.random()-0.5)*60, (Math.random()-0.5)*60 + 20, (Math.random()-0.5)*60);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color: 0xffffff, size: 0.3, transparent: true, opacity: 0.8});
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function createMMText() {
            const c = document.createElement('canvas'); c.width=256; c.height=128;
            const ctx = c.getContext('2d');
            ctx.font = 'bold 80px "Great Vibes"';
            ctx.fillStyle = '#ff69b4'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.shadowColor = "#fff"; ctx.shadowBlur = 10;
            ctx.fillText("mm", 128, 64);
            const tex = new THREE.CanvasTexture(c);
            const mat = new THREE.SpriteMaterial({map:tex, transparent:true, opacity:0});
            mmTextSprite = new THREE.Sprite(mat);
            mmTextSprite.scale.set(8, 4, 1);
            mmTextSprite.position.set(0, 5, 2);
            scene.add(mmTextSprite);
        }

        // --- 4. è§’è‰² & æ¨¡å‹ ---
        function loadModel(name) {
            const loader = new MMDLoader();
            if(currentModel) scene.remove(currentModel);

            loader.load(MODELS[name], (mesh) => {
                currentModel = mesh;
                // å›ºå®šä½ç½®ï¼šå·¦åæ–¹ (-15, -10, -5)
                mesh.position.set(-15, -12, -5);
                mesh.rotation.y = 0.5; // é¢å‘å±å¹•ä¸­å¿ƒåå³ä¸€ç‚¹
                mesh.scale.set(0.85, 0.85, 0.85);

                mesh.material.forEach(m => {
                    m.emissive = new THREE.Color(0x222222);
                    if(name === 'usagi') m.color.setHex(0xFFEEAA);
                });
                scene.add(mesh);
            }, null, (e) => console.log('Model load error (needs local server):', e));
        }

        window.switchModel = (name) => {
            loadModel(name);
            document.querySelectorAll('#controls .btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        // --- 5. äº¤äº’é€»è¾‘ (MediaPipe) ---
        let handLandmarker;
        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2 // éœ€è¦æ£€æµ‹åŒæ‰‹
            });
        }

        async function startCamera() {
            const video = document.getElementById('camera-preview');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.addEventListener('loadeddata', () => predictWebcam());
        }

        let lastVideoTime = -1;
        function predictWebcam() {
            const video = document.getElementById('camera-preview');
            const now = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, now);
                processGestures(result);
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(result) {
            const uiItems = document.querySelectorAll('.g-item');
            uiItems.forEach(i => i.classList.remove('active'));
            const msgBox = document.getElementById('custom-message-box');

            // é»˜è®¤çŠ¶æ€
            let newState = 'tree'; 
            let activeUI = 'g-tree';
            let newClench = 0;

            if (result.landmarks.length > 0) {
                // 1. æ£€æµ‹åŒæ‰‹çˆ±å¿ƒ (Two Hands Love)
                if (result.landmarks.length === 2) {
                    const h1 = result.landmarks[0];
                    const h2 = result.landmarks[1];
                    // ç®€å•åˆ¤æ–­ï¼šä¸¤æ‰‹é£ŸæŒ‡å°–(8)é è¿‘ï¼Œæ‹‡æŒ‡å°–(4)é è¿‘
                    const idxDist = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const thmDist = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    
                    if (idxDist < 0.15 && thmDist < 0.15) {
                        newState = 'love';
                        activeUI = 'g-love';
                    }
                }

                // 2. å¦‚æœä¸æ˜¯åŒæ‰‹çˆ±å¿ƒï¼Œæ£€æµ‹å•æ‰‹æ‰‹åŠ¿
                if (newState !== 'love') {
                    const lm = result.landmarks[0]; // åªçœ‹ç¬¬ä¸€åªæ‰‹
                    const wrist = lm[0];
                    
                    // è®¡ç®—å¼€åˆåº¦ (æŒ‡å°–åˆ°æ‰‹è…•å¹³å‡è·ç¦»)
                    const tips = [8,12,16,20];
                    let dist = 0;
                    tips.forEach(i => dist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                    dist /= 4;

                    // è®¡ç®—æåˆ (æ‹‡æŒ‡4 - é£ŸæŒ‡8)
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                    if (pinchDist < 0.05) {
                        newState = 'pinch';
                        activeUI = 'g-pinch';
                        // è®°å½•æåˆåº¦ç”¨äºåŠ¨ç”»è¿‡æ¸¡
                        newClench = 0.5; 
                    } else if (dist < 0.25) {
                        newState = 'heart'; // æ¡æ‹³
                        activeUI = 'g-fist';
                        newClench = 1;
                    } else if (dist > 0.4) {
                        newState = 'firework'; // å¼ å¼€
                        activeUI = 'g-burst';
                        newClench = 0;
                    }
                }
            }

            // æ›´æ–°çŠ¶æ€
            state = newState;
            document.getElementById(activeUI).classList.add('active');

            // éª¨éª¼åŠ¨ç”»æ’å€¼
            handClench += (newClench - handClench) * 0.1;

            // æ–‡å­—æ¡†æ˜¾éš
            msgBox.style.display = (state === 'love') ? 'block' : 'none';
        }

        // --- 6. ç…§ç‰‡ç®¡ç† ---
        function handleImageUpload(e) {
            const files = e.target.files;
            photoMeshGroup.clear(); // æ¸…ç©ºæ—§ç…§ç‰‡
            
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        const aspect = img.height / img.width;
                        const geo = new THREE.PlaneGeometry(3, 3*aspect);
                        const mat = new THREE.MeshBasicMaterial({map: tex, side: THREE.DoubleSide});
                        const mesh = new THREE.Mesh(geo, mat);

                        // éšæœºæŒ‚è½½ä½ç½® (åœ†é”¥è¡¨é¢)
                        const y = (Math.random() - 0.5) * TREE_H; // -12.5 to 12.5
                        const radiusAtY = TREE_R * (1 - (y + TREE_H/2)/TREE_H);
                        const angle = Math.random() * Math.PI * 2;
                        
                        // å­˜åŸå§‹æ ‘ä½ç½®
                        mesh.userData.treePos = new THREE.Vector3(
                            Math.cos(angle)*(radiusAtY+1), // ç¨å¾®æµ®å‡ºä¸€ç‚¹
                            y,
                            Math.sin(angle)*(radiusAtY+1)
                        );
                        
                        mesh.position.copy(mesh.userData.treePos);
                        mesh.lookAt(0, y, 0); // é¢å‘æ ‘å¹²
                        photoMeshGroup.add(mesh);
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        // --- 7. ä¸»åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. çŒæˆ·åº§é—ªçƒ
            orionStars.forEach((star, idx) => {
                // åˆ©ç”¨sinæ³¢äº§ç”Ÿéšæœºé—ªçƒ
                const flicker = Math.sin(time * 5 + star.userData.randomPhase) * 0.2 + 1; 
                star.scale.setScalar(star.userData.baseScale * flicker);
            });

            // 2. ç²’å­é€»è¾‘
            updateParticles(time);

            // 3. ç…§ç‰‡é€»è¾‘ (Tree / Pinch)
            updatePhotos(time);

            // 4. æ–‡å­—é€»è¾‘
            if(state === 'heart') {
                mmTextSprite.material.opacity = THREE.MathUtils.lerp(mmTextSprite.material.opacity, 1, 0.05);
            } else {
                mmTextSprite.material.opacity = THREE.MathUtils.lerp(mmTextSprite.material.opacity, 0, 0.1);
            }

            // 5. è§’è‰²æ‰‹è‡‚éª¨éª¼è”åŠ¨
            updateCharacterBones();

            // 6. é›ªèŠ±ä¸‹è½
            updateSnow();

            // æ¸²æŸ“
            composer.render();
        }

        function updateParticles(time) {
            const pos = particles.geometry.attributes.position.array;
            const tTree = particles.geometry.attributes.targetTree.array;
            const tHeart = particles.geometry.attributes.targetHeart.array;
            const vel = particles.geometry.attributes.velocity.array;

            for(let i=0; i<P_COUNT; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;

                if (state === 'firework') {
                    // çˆ†ç‚¸
                    if (vel[iy] === 0) {
                        vel[ix] = (Math.random()-0.5)*0.8;
                        vel[iy] = (Math.random()-0.5)*0.8;
                        vel[iz] = (Math.random()-0.5)*0.8;
                    }
                    pos[ix] += vel[ix];
                    pos[iy] += vel[iy];
                    pos[iz] += vel[iz];
                } else {
                    // å½’ä½é€»è¾‘ (Tree or Heart or Love)
                    vel[ix]=0; vel[iy]=0; vel[iz]=0;
                    
                    let tx, ty, tz;
                    // 'love' çŠ¶æ€ä¹Ÿç”¨ Heart å½¢çŠ¶
                    if (state === 'heart' || state === 'love') {
                        tx = tHeart[ix]; ty = tHeart[iy]; tz = tHeart[iz];
                    } else {
                        // Tree: åŠ å…¥æ—‹è½¬
                        const x0 = tTree[ix], z0 = tTree[iz];
                        const angle = time * 0.5;
                        tx = x0 * Math.cos(angle) - z0 * Math.sin(angle);
                        ty = tTree[iy];
                        tz = x0 * Math.sin(angle) + z0 * Math.cos(angle);
                    }

                    // ç¼“åŠ¨
                    pos[ix] += (tx - pos[ix]) * 0.08;
                    pos[iy] += (ty - pos[iy]) * 0.08;
                    pos[iz] += (tz - pos[iz]) * 0.08;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        function updatePhotos(time) {
            // Pinch æ¨¡å¼: æ‰¾æœ€è¿‘çš„ç…§ç‰‡æ”¾å¤§åˆ°ä¸­é—´
            let targetMesh = null;
            if (state === 'pinch' && photoMeshGroup.children.length > 0) {
                // ç®€å•çš„é€»è¾‘ï¼šæ‰¾æ•°ç»„ç¬¬ä¸€ä¸ªæˆ–è€…ç¦»ç›¸æœºè§†çº¿æœ€è¿‘çš„
                // è¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œç›´æ¥é€‰ç¬¬ä¸€ä¸ªï¼Œæˆ–è€…éšæœºé€‰ä¸€ä¸ª
                targetMesh = photoMeshGroup.children[0]; 
            }

            photoMeshGroup.children.forEach((mesh, idx) => {
                if (state === 'firework') {
                    // éšç²’å­æ•£å¼€
                    mesh.position.y -= 0.1;
                    mesh.rotation.z += 0.05;
                } else if (state === 'pinch' && mesh === targetMesh) {
                    // èšç„¦æ¨¡å¼ï¼šç§»åˆ°å±å¹•ä¸­å¿ƒå‰æ–¹
                    const focusPos = new THREE.Vector3(0, 5, 25); // ç›¸æœºåœ¨ z=45
                    mesh.position.lerp(focusPos, 0.1);
                    mesh.lookAt(camera.position);
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, 2.5, 0.1)); // æ”¾å¤§
                } else if (state === 'tree') {
                    // æ ‘æ¨¡å¼ï¼šæ—‹è½¬
                    const treePos = mesh.userData.treePos;
                    const angle = time * 0.5;
                    const x = treePos.x * Math.cos(angle) - treePos.z * Math.sin(angle);
                    const z = treePos.x * Math.sin(angle) + treePos.z * Math.cos(angle);
                    
                    mesh.position.lerp(new THREE.Vector3(x, treePos.y, z), 0.1);
                    mesh.lookAt(0, treePos.y, 0);
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, 1, 0.1));
                } else {
                    // å¿ƒå½¢/Loveæ¨¡å¼ï¼šç¼©å°éšè—
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, 0, 0.2));
                }
            });
        }

        function updateCharacterBones() {
            if (!currentModel || !currentModel.skeleton) return;
            
            // è·å–æ‰‹è‡‚éª¨éª¼ (MMD å‘½åé€šå¸¸æ˜¯æ—¥è¯­)
            const bones = currentModel.skeleton.bones;
            const armL = bones.find(b => b.name === 'å·¦è…•'); // Left Arm
            const armR = bones.find(b => b.name === 'å³è…•'); // Right Arm

            if (armL && armR) {
                // æ ¹æ® handClench (0~1) æ’å€¼æ—‹è½¬
                // 0 (å¼ å¼€) -> æ‰‹è‡‚ä¸‹å‚/å¼ å¼€
                // 1 (æ¡æ‹³) -> æ‰‹è‡‚æŠ±ç´§/æŠ¬èµ·
                const zRot = THREE.MathUtils.lerp(-0.5, 0.8, handClench);
                const xRot = THREE.MathUtils.lerp(0, -0.5, handClench);

                armL.rotation.z = zRot;
                armL.rotation.x = xRot;
                armR.rotation.z = -zRot;
                armR.rotation.x = xRot;
            }
        }

        function updateSnow() {
            const pos = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<pos.length; i+=3) {
                pos[i+1] -= 0.1; // ä¸‹è½
                pos[i] += Math.sin(pos[i+1]*0.1) * 0.05; // é£˜åŠ¨
                
                if (pos[i+1] < -20) {
                    pos[i+1] = 30;
                    pos[i] = (Math.random()-0.5)*60;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 8. éŸ³é¢‘ç³»ç»Ÿ (Web Audio API) ---
        function initAudioSystem() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            
            // ç®€å•çš„éŸ³ç¬¦é¢‘ç‡ (C Major)
            const tune = [
                {f:392, d:400}, {f:523, d:400}, {f:523, d:200}, {f:587, d:200}, 
                {f:523, d:200}, {f:493, d:200}, {f:440, d:400}, {f:440, d:400},
                {f:440, d:400}, {f:587, d:400}, {f:587, d:200}, {f:659, d:200},
                {f:587, d:200}, {f:523, d:200}, {f:493, d:400}, {f:392, d:400}
            ]; // We Wish You a Merry Christmas ç‰‡æ®µ
            
            let noteIdx = 0;

            window.toggleMusic = function() {
                isMusicPlaying = !isMusicPlaying;
                const btn = document.getElementById('music-btn');
                
                if (isMusicPlaying) {
                    if(audioCtx.state === 'suspended') audioCtx.resume();
                    btn.classList.add('active');
                    playNextNote();
                } else {
                    btn.classList.remove('active');
                    clearTimeout(musicTimer);
                }
            };

            function playNextNote() {
                if (!isMusicPlaying) return;
                const note = tune[noteIdx];
                playTone(note.f, note.d);
                noteIdx = (noteIdx + 1) % tune.length;
                musicTimer = setTimeout(playNextNote, note.d * 1.1);
            }

            function playTone(freq, duration) {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle'; // æŸ”å’Œçš„éŸ³è‰²
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration/1000);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration/1000);
            }
        }
    </script>
</body>
</html>
