<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 粒子圣诞树 & 吉依卡哇</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: "PingFang SC", sans-serif; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* UI 界面 */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .btn-group {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(5px);
            padding: 10px;
            border-radius: 20px;
            display: inline-block;
        }

        button {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 12px;
            font-size: 14px;
            cursor: pointer;
            transition: 0.3s;
        }
        button.active { background: #ff4757; border-color: #ff4757; }
        
        #status {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00d2ff;
            text-shadow: 0 0 5px black;
            z-index: 20;
            pointer-events: none;
            font-size: 16px;
        }

        /* 隐藏视频源，但在iOS微信中必须保留并在视口内才能运行 */
        #video-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0.01;
            z-index: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="status">正在初始化...<br>请允许摄像头权限</div>

    <video id="video-preview" playsinline webkit-playsinline muted></video>

    <div id="ui-layer">
        <div class="btn-group">
            <button onclick="switchModel('hachiware')" id="btn-hachiware" class="active">小八</button>
            <button onclick="switchModel('usagi')" id="btn-usagi">乌萨奇</button>
            <button onclick="switchModel('chiikawa')" id="btn-chiikawa">吉依卡哇</button>
        </div>
        <p style="color: rgba(255,255,255,0.6); font-size: 12px; margin-top: 5px;">
            握拳：变圣诞树 | 张手：放烟花
        </p>
    </div>

    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- 核心变量 ---
        let scene, camera, renderer, controls;
        let particles = [], particleGroup;
        let currentModel = null;
        let currentModelName = 'hachiware';
        
        // 状态变量
        let targetShape = 'random'; 
        let isHandDetected = false;
        let handPosition = new THREE.Vector3(0, 0, 0); 
        let clock = new THREE.Clock();

        // 圣诞树参数
        const TREE_HEIGHT = 25;
        const TREE_RADIUS = 10;
        const PARTICLE_COUNT = 1500; 

        // 模型文件映射 (请确保文件名与你上传的一致)
        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        // --- 初始化 ---
        async function init() {
            setupScene();
            createParticles();
            
            // 默认加载小八
            loadMMDModel('hachiware');

            // 启动 AI
            setupMediaPipe();
            
            animate();
            
            // 绑定全局切换函数
            window.switchModel = (name) => {
                if (currentModelName === name) return;
                currentModelName = name;
                
                // 更新按钮样式
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${name}`).classList.add('active');
                
                loadMMDModel(name);
            };
        }

        // --- 1. 场景设置 ---
        function setupScene() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            // 稍微带点蓝色星空背景
            scene.fog = new THREE.FogExp2(0x0a0a10, 0.02);
            scene.background = new THREE.Color(0x050505);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // 灯光 (为了让 MMD 模型显示正常)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 20);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            // 地面网格
            const grid = new THREE.GridHelper(100, 20, 0x333333, 0x111111);
            grid.position.y = -10;
            scene.add(grid);
        }

        // --- 2. MMD 模型加载逻辑 ---
        function loadMMDModel(name) {
            const path = MODELS[name];
            const loader = new MMDLoader();
            
            document.getElementById('status').innerText = `正在加载 ${name}...`;

            // 移除旧模型
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }

            loader.load(
                path, 
                (mesh) => {
                    currentModel = mesh;
                    
                    // 调整模型大小和位置
                    mesh.scale.set(1.5, 1.5, 1.5); 
                    mesh.position.set(12, -8, 0); // 放在树的右边
                    
                    // 处理材质：因为没有贴图文件，我们给一个基础颜色防止变成全白
                    // 小八：蓝白，乌萨奇：黄，吉依卡哇：白
                    mesh.material.forEach(mat => {
                        // 简单的颜色回退逻辑
                        mat.emissive = new THREE.Color(0x222222); // 自发光一点点防止太黑
                        if (name === 'usagi') mat.color.setHex(0xFFEEAA);
                        if (name === 'hachiware') mat.color.setHex(0xFFFFFF); // 默认白，靠贴图，如果没有贴图就是白模
                        mat.needsUpdate = true;
                    });

                    scene.add(mesh);
                    document.getElementById('status').innerText = "模型加载完毕 | 等待手势...";
                },
                (xhr) => {
                    // 加载进度
                    if (xhr.lengthComputable) {
                        const percent = Math.round((xhr.loaded / xhr.total) * 100);
                        document.getElementById('status').innerText = `加载 ${name}: ${percent}%`;
                    }
                },
                (error) => {
                    console.error(error);
                    document.getElementById('status').innerHTML = `加载失败<br>请确保 ${path} 在同一目录下<br>且使用HTTPS访问`;
                    // 失败时创建一个替代的方块，保证交互可用
                    createFallbackModel(name);
                }
            );
        }

        // 如果模型加载失败（比如本地打开没开服务器），创建一个简单的几何体代替
        function createFallbackModel(name) {
            const colors = { 'hachiware': 0x6495ED, 'usagi': 0xFFFF00, 'chiikawa': 0xFFFFFF };
            const geometry = new THREE.CapsuleGeometry(2, 4, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: colors[name] });
            currentModel = new THREE.Mesh(geometry, material);
            currentModel.position.set(12, -5, 0);
            scene.add(currentModel);
            document.getElementById('status').innerText = "使用替代模型 (加载文件失败)";
        }

        // --- 3. 粒子系统 (无需上传图片) ---
        function createParticles() {
            particleGroup = new THREE.Group();
            scene.add(particleGroup);

            // 生成纹理：发光的圆形
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);

            // 预定义颜色：金、红、绿、银 (圣诞色)
            const colors = [0xFFD700, 0xFF0000, 0x00FF00, 0xFFFFFF, 0x00FFFF];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    color: color,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const sprite = new THREE.Sprite(material);
                
                // 初始：全屏随机分布
                sprite.position.set(
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 60
                );
                sprite.scale.set(0.8, 0.8, 1);

                // 计算圣诞树形态的目标位置
                const pData = {
                    mesh: sprite,
                    initialPos: sprite.position.clone(),
                    treePos: new THREE.Vector3(),
                    fireworkVel: new THREE.Vector3(),
                    angleOffset: Math.random() * Math.PI * 2
                };

                // 圣诞树数学模型 (螺旋圆锥)
                const yNorm = i / PARTICLE_COUNT; 
                const y = yNorm * TREE_HEIGHT - (TREE_HEIGHT / 2); 
                const r = TREE_RADIUS * (1 - yNorm); 
                const angle = i * 0.2 + pData.angleOffset;
                
                pData.treePos.set(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );

                particles.push(pData);
                particleGroup.add(sprite);
            }
        }

        function updateParticles(dt) {
            const time = Date.now() * 0.001;

            particles.forEach(p => {
                const current = p.mesh.position;

                if (targetShape === 'tree') {
                    // 握拳：变成树
                    const target = p.treePos.clone();
                    // 加上一点旋转效果
                    const rotSpeed = 1.0;
                    const cos = Math.cos(time * rotSpeed);
                    const sin = Math.sin(time * rotSpeed);
                    const x = target.x * cos - target.z * sin;
                    const z = target.x * sin + target.z * cos;
                    target.x = x; target.z = z;

                    current.lerp(target, 0.08); // 平滑移动
                    p.mesh.scale.setScalar(0.8);
                    
                } else if (targetShape === 'firework') {
                    // 张手：烟花爆炸
                    if (p.fireworkVel.lengthSq() === 0) {
                        p.fireworkVel.copy(current).normalize().multiplyScalar(Math.random() * 0.8 + 0.2);
                        p.fireworkVel.y += Math.random() * 0.2;
                    }
                    current.add(p.fireworkVel);
                    p.fireworkVel.y -= 0.01; // 重力
                    p.mesh.material.opacity -= 0.015;
                    
                    // 重置
                    if (p.mesh.material.opacity <= 0) {
                        p.mesh.position.set(0,0,0);
                        p.mesh.material.opacity = 1;
                        p.fireworkVel.set(0,0,0);
                    }
                } else {
                    // 默认/随机漂浮
                    const floatY = Math.sin(time + current.x * 0.5) * 0.05;
                    current.y += floatY;
                    current.lerp(p.initialPos, 0.02);
                    p.mesh.material.opacity = 1;
                    p.fireworkVel.set(0,0,0);
                }
            });
        }

        // --- 4. 手势识别 (MediaPipe) ---
        let handLandmarker;
        let webcamRunning = false;
        
        async function setupMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                startCamera();
            } catch (e) {
                console.error(e);
                document.getElementById('status').innerText = "AI 模型加载失败 (网络原因)";
            }
        }

        async function startCamera() {
            const video = document.getElementById("video-preview");
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                document.getElementById('status').innerText = "浏览器不支持摄像头或未开启HTTPS";
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "user", width: 480, height: 360 } 
                });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    webcamRunning = true;
                    video.play();
                    document.getElementById('status').innerText = ""; // 清空提示
                });
            } catch (err) {
                document.getElementById('status').innerText = "摄像头启动失败: " + err.message;
            }
        }

        let lastVideoTime = -1;
        function detectGesture() {
            if (!handLandmarker || !webcamRunning) return;
            const video = document.getElementById("video-preview");
            
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks && results.landmarks.length > 0) {
                    isHandDetected = true;
                    const landmarks = results.landmarks[0];
                    
                    // 1. 获取手掌位置 (用于控制模型头部旋转)
                    // MediaPipe x轴反向: 1在左, 0在右 (镜像) -> 映射到 -30 ~ 30
                    const x = (0.5 - landmarks[0].x) * 50; 
                    const y = (0.5 - landmarks[0].y) * 30;
                    handPosition.set(x, y, 10);

                    // 2. 简单的手势判断逻辑
                    // 比较 食指指尖(8) 到 掌跟(0) 的距离
                    const wrist = landmarks[0];
                    const indexTip = landmarks[8];
                    const dist = Math.sqrt(
                        Math.pow(indexTip.x - wrist.x, 2) + 
                        Math.pow(indexTip.y - wrist.y, 2)
                    );

                    // 阈值需要根据摄像头实际情况微调
                    if (dist < 0.25) { // 拳头 (指尖离手腕近)
                        targetShape = 'tree';
                    } else if (dist > 0.35) { // 只有明显张开才算烟花
                        targetShape = 'firework';
                    } else {
                        // 保持上一状态或者变回 random
                        // targetShape = 'random';
                    }
                } else {
                    isHandDetected = false;
                    targetShape = 'random';
                }
            }
        }

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            detectGesture();
            updateParticles(dt);

            // 更新模型动作 (LookAt)
            if (currentModel) {
                if (isHandDetected) {
                    // 让模型看向手的位置
                    // 创建一个临时的目标点，稍微平滑一下
                    const lookTarget = new THREE.Vector3().copy(handPosition);
                    lookTarget.x += 12; // 补偿模型本身的偏移
                    
                    // 限制头部旋转角度，防止恐怖片效果
                    currentModel.lookAt(lookTarget); 
                    
                    // 如果握拳，模型跳跃
                    if (targetShape === 'tree') {
                        currentModel.position.y = -8 + Math.abs(Math.sin(Date.now() * 0.005)) * 3;
                    } else {
                        currentModel.position.y = -8;
                    }
                } else {
                    // 没手时，慢慢转回正面
                    currentModel.rotation.set(0, 0, 0);
                    currentModel.position.y = -8;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        init();

    </script>
</body>
</html>