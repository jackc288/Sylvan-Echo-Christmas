<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sylvan Echo Christmas</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    
    <!-- ä½¿ç”¨å…¨å±€è„šæœ¬ï¼Œç¡®ä¿ç§»åŠ¨ç«¯å…¼å®¹æ€§ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r162/three.min.js"></script>
    <!-- æ ¹æ®éœ€è¦å¼•å…¥åå¤„ç†åº“ -->
    <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://threejs.org/examples/js/loaders/MMDLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm/vision_bundle.js"></script>
    <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
    
    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: #000; /* çº¯é»‘åº• */
            font-family: 'Cinzel', serif;
            user-select: none; -webkit-user-select: none;
        }

        /* é¡¶éƒ¨æ ‡é¢˜ - é€‚é…æ‰‹æœº */
        #top-title {
            position: absolute; top: 5%; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }
        #top-title h1 {
            font-family: 'Great Vibes', cursive; font-size: 3rem; color: #ffdae0; margin: 0;
            text-shadow: 0 0 15px rgba(255, 182, 193, 0.8), 0 0 30px rgba(255, 105, 180, 0.5);
            animation: breathe 4s infinite ease-in-out;
            transition: font-size 0.3s;
        }
        @keyframes breathe { 50% { opacity: 0.8; text-shadow: 0 0 25px rgba(255, 105, 180, 0.9); } }

        /* åŒæ‰‹çˆ±å¿ƒå¼¹çª— */
        #custom-message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(40, 20, 40, 0.4); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 105, 180, 0.3); border-radius: 20px;
            padding: 30px 50px; text-align: center; color: #fff;
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.2);
            display: none; z-index: 50; width: 80%; max-width: 400px;
            animation: popIn 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #custom-message-box textarea {
            background: transparent; border: none; color: #fff; font-size: 1.5rem; 
            font-family: 'Great Vibes', cursive; text-align: center; width: 100%; resize: none; outline: none;
            text-shadow: 0 0 5px rgba(255,192,203,0.5);
        }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* æ‘„åƒå¤´ & æŒ‡å— */
        #camera-preview {
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px;
            border: 2px solid rgba(255, 192, 203, 0.4); border-radius: 12px;
            background: rgba(0,0,0,0.5); transform: scaleX(-1); object-fit: cover; z-index: 20;
            opacity: 0.7; transition: opacity 0.3s;
        }
        #camera-preview:hover { opacity: 1; }

        #gesture-guide {
            position: absolute; top: 15%; right: 20px; width: 200px;
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 12px;
            border-right: 3px solid #ff69b4; color: #ddd; font-size: 0.8rem; 
            z-index: 15; pointer-events: none;
            transform-origin: top right;
        }
        .g-item { margin-bottom: 8px; opacity: 0.5; transition: 0.3s; display: flex; align-items: center; justify-content: flex-end;}
        .g-item.active { opacity: 1; color: #fff; font-weight: bold; text-shadow: 0 0 8px #ff69b4; transform: translateX(-5px); }

        /* åº•éƒ¨æ§åˆ¶æ  */
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; align-items: center; z-index: 20;
            background: rgba(20, 20, 30, 0.6); padding: 8px 15px; border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1); backdrop-filter: blur(5px);
            width: max-content; max-width: 90%; flex-wrap: nowrap; overflow-x: auto;
        }
        .btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white;
            padding: 6px 12px; border-radius: 20px; cursor: pointer; 
            font-family: 'Cinzel', serif; font-size: 0.75rem;
            transition: 0.3s; white-space: nowrap;
        }
        .btn:hover, .btn.active { background: #ff69b4; border-color: #ff69b4; color: #000; box-shadow: 0 0 10px #ff69b4; }
        
        /* éšè—æ»šåŠ¨æ¡ */
        #controls::-webkit-scrollbar { display: none; }

        /* Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #ffdae0;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid #333; border-top: 3px solid #ff69b4;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* èšç„¦ç…§ç‰‡æ—¶çš„é®ç½© */
        #photo-focus-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 30; display: none;
            justify-content: center; align-items: center; flex-direction: column;
        }
        #focused-photo-title {
            color: white; font-size: 1.5rem; margin-bottom: 20px;
            font-family: 'Great Vibes', cursive;
        }
        #close-focus-btn {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255,255,255,0.1); color: white; border: none;
            width: 40px; height: 40px; border-radius: 50%; font-size: 1.5rem;
            cursor: pointer; z-index: 31;
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 600px) {
            #top-title h1 { font-size: 2rem; }
            #gesture-guide { transform: scale(0.7); top: 10%; right: 10px; }
            #camera-preview { width: 80px; height: 60px; bottom: 80px; left: 10px; opacity: 0.5; }
            #controls { bottom: 20px; padding: 6px 10px; }
            .btn { padding: 5px 10px; font-size: 0.7rem; }
            #custom-message-box { padding: 20px 30px; width: 85%; }
            #focused-photo-title { font-size: 1.2rem; }
        }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">Loading Sylvan Echo...</div>
        <button id="start-btn" class="btn" style="display:none; margin-top:20px; font-size: 1rem; padding: 10px 30px;">Enter Magic</button>
    </div>

    <div id="top-title"><h1>Sylvan Echo, Happy Christmas</h1></div>

    <div id="custom-message-box">
        <textarea rows="2">æ„¿æ­¤æ—¶åˆ»ï¼Œæ°¸é©»å¿ƒé—´</textarea>
    </div>

    <!-- ç…§ç‰‡èšç„¦è§†å›¾ -->
    <div id="photo-focus-overlay">
        <button id="close-focus-btn">Ã—</button>
        <div id="focused-photo-title">å›å¿†èšç„¦</div>
        <!-- èšç„¦çš„ç…§ç‰‡å°†åŠ¨æ€æ”¾ç½®åœ¨è¿™é‡Œ -->
    </div>

    <video id="camera-preview" playsinline muted autoplay></video>

    <div id="gesture-guide">
        <div class="g-item" id="g-tree">ğŸ– æ— æ‰‹åŠ¿: åœ£è¯æ ‘ + é‡‘æ˜Ÿ</div>
        <div class="g-item" id="g-fist">âœŠ æ¡æ‹³: "mm"çˆ±å¿ƒ</div>
        <div class="g-item" id="g-burst">ğŸ‘‹ å¼ æ‰‹: æ•£å¼€ & æ‰‡åŠ¨æ—‹è½¬</div>
        <div class="g-item" id="g-pinch">ğŸ‘Œ å¼ æ‰‹+æåˆ: æ£€è§†ç…§ç‰‡</div>
        <div class="g-item" id="g-love">ğŸ«¶ åŒæ‰‹: å¬å”¤ç¥ç¦</div>
    </div>

    <div id="controls">
        <button class="btn" id="music-btn">ğŸµ Music</button>
        <div style="width:1px; height:15px; background:rgba(255,255,255,0.3); margin: 0 5px;"></div>
        <button class="btn active" onclick="switchModel('hachiware')">å°å…«</button>
        <button class="btn" onclick="switchModel('usagi')">ä¹Œè¨å¥‡</button>
        <button class="btn" onclick="switchModel('chiikawa')">å‰ä¾å¡å“‡</button>
    </div>

    <div id="canvas-container"></div>

    <script>
        // === å…¨å±€å˜é‡ ===
        let scene, camera, renderer, composer;
        let particles, phantomTreeInstances, topStar;
        let photoMeshGroup = new THREE.Group();
        let snowSystem;
        let orionStars = [];
        let mmTextSprite;
        let currentModel = null;
        let currentSelectedPhoto = null;
        let isPhotoFocused = false;
        let originalCameraPosition = new THREE.Vector3();
        let originalCameraRotation = new THREE.Euler();

        // æ‰‹åŠ¿è¯†åˆ«ç›¸å…³
        let handLandmarker = null;
        let lastHandX = 0;
        let handVelocityX = 0;
        let handClench = 0;
        let webcamRunning = false;
        let lastVideoTime = -1;

        // çŠ¶æ€
        let state = 'tree';
        let sceneRotationSpeed = 0.002;
        let clock = new THREE.Clock();

        // å¸¸é‡
        const P_COUNT = 1200; // ä¸»æ ‘ç²’å­æ•°
        const PHANTOM_COUNT = 600; // å¹»å½±æ ‘ç²’å­æ•°
        const TREE_H = 25;
        const TREE_R = 12;

        // é¢„è®¾ç…§ç‰‡åˆ—è¡¨ (è¯·ç¡®ä¿æ–‡ä»¶åä¸€è‡´)
        const PRESET_PHOTOS = ['love1.jpg', 'love2.jpg', 'love3.jpg', 'love4.jpg', 'love5.jpg'];

        // æ¨¡å‹è·¯å¾„
        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        // === 1. é¡µé¢åŠ è½½åˆå§‹åŒ– ===
        window.onload = function() {
            console.log("é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...");
            // åˆå§‹åŒ–è°ƒè¯•å·¥å…·
            if (typeof VConsole !== 'undefined') {
                var vConsole = new VConsole({ theme: 'dark' });
                console.log('vConsole è°ƒè¯•å·¥å…·å·²å¯ç”¨');
            }
            
            // æ£€æŸ¥Three.js
            if (!window.THREE) {
                showError("Three.jsåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•");
                return;
            }
            console.log("âœ“ Three.js åŠ è½½æˆåŠŸ");
            
            // æ˜¾ç¤ºå¼€å§‹æŒ‰é’®
            document.getElementById('loading-text').innerText = "Ready to Enter";
            document.getElementById('start-btn').style.display = 'block';
        };

        document.getElementById('start-btn').addEventListener('click', async function() {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
            
            // åˆå§‹åŒ–æ ¸å¿ƒåŠŸèƒ½
            initThree();
            initAudio();
            loadModel('hachiware');
            loadPresetPhotos();
            
            // åˆå§‹åŒ–AIå’Œæ‘„åƒå¤´
            try {
                await initHandTracking();
                await startCamera();
                console.log("âœ“ æ‰‹åŠ¿è¯†åˆ«ä¸æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ");
            } catch (error) {
                console.warn("AI/æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:", error);
                document.getElementById('status').innerText = "æ‰‹åŠ¿è¯†åˆ«åŠ è½½å¤±è´¥ï¼Œè¯·ä½¿ç”¨å…¶ä»–äº¤äº’";
            }
            
            animate();
        });

        // === 2. 3Dåœºæ™¯ä¸è¾‰å…‰æ•ˆæœ ===
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 45);
            originalCameraPosition.copy(camera.position);
            originalCameraRotation.copy(camera.rotation);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            // === åˆ›å»ºåå¤„ç†è¾‰å…‰æ•ˆæœ ===
            // æ³¨æ„ï¼šç”±äºUnrealBloomPasså¯èƒ½åŠ è½½å¤±è´¥ï¼Œè¿™é‡Œä½¿ç”¨try-catchåŒ…è£¹
            try {
                const renderScene = new THREE.RenderPass(scene, camera);
                // ä½¿ç”¨ä½ è¦æ±‚çš„é«˜é˜ˆå€¼å’Œå¼ºåº¦è®¾ç½®
                const bloomPass = new THREE.UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    2.0, // å¼ºåº¦è¾ƒé«˜
                    0.1, // é˜ˆå€¼è¾ƒé«˜ï¼Œåªæœ‰è¾ƒäº®éƒ¨åˆ†å‘å…‰
                    0.85
                );
                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);
                console.log("âœ“ è¾‰å…‰åå¤„ç†æ•ˆæœå·²å¯ç”¨");
            } catch (e) {
                console.warn("åå¤„ç†æ•ˆæœåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨æ ‡å‡†æ¸²æŸ“:", e);
                composer = null;
            }

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffd700, 1.5);
            mainLight.position.set(15, 25, 15);
            mainLight.castShadow = true;
            scene.add(mainLight);

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createNaturalNebula();
            createOrion();
            createMainTree();      // åŒå±‚ç²’å­ä¸»æ ‘
            createPhantomTree();   // InstancedMeshå¹»å½±æ ‘
            createTopStar();
            createSnow();
            createMMText();
            scene.add(photoMeshGroup);

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // === 3. åŒå±‚åœ£è¯æ ‘ç²’å­ç³»ç»Ÿ (æŒ‰ä½ çš„è¦æ±‚) ===
        function createMainTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const treeTargets = [];
            const heartTargets = [];
            
            // é‡‘è‰²å’Œç²‰è‰²
            const goldColor = new THREE.Color(0xD4AF37);
            const pinkColor = new THREE.Color(0xFF69B4);
            
            for(let i = 0; i < P_COUNT; i++) {
                // åˆå§‹éšæœºä½ç½®
                positions.push(
                    (Math.random()-0.5) * 60,
                    (Math.random()-0.5) * 60,
                    (Math.random()-0.5) * 60
                );
                
                // éšæœºåˆ†é…é‡‘è‰²æˆ–ç²‰è‰²
                const useGold = Math.random() > 0.5;
                const color = useGold ? goldColor : pinkColor;
                colors.push(color.r, color.g, color.b);
                
                // åœ†é”¥èºæ—‹ç›®æ ‡ä½ç½®
                const r = i / P_COUNT;
                const y = r * TREE_H - TREE_H/2;
                const radius = TREE_R * (1 - r);
                const angle = i * 0.25; // èºæ—‹å¯†åº¦
                
                treeTargets.push(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                
                // å¿ƒå½¢ç›®æ ‡ä½ç½®ï¼ˆç”¨äºçˆ±å¿ƒçŠ¶æ€ï¼‰
                const t = Math.random() * Math.PI * 2;
                const scale = 0.7;
                const heartX = 16 * Math.pow(Math.sin(t), 3);
                const heartY = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                heartTargets.push(heartX * scale, heartY * scale + 5, (Math.random()-0.5)*8);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('treeTarget', new THREE.Float32BufferAttribute(treeTargets, 3));
            geometry.setAttribute('heartTarget', new THREE.Float32BufferAttribute(heartTargets, 3));
            
            // ä½¿ç”¨MeshStandardMaterialä»¥è·å¾—æ›´å¥½çš„å…‰ç…§å’Œå‘å…‰æ•ˆæœ
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                emissive: new THREE.Color(0x333333), // åŸºç¡€è‡ªå‘å…‰
                emissiveIntensity: 0.3,
                roughness: 0.1,
                metalness: 0.3,
                transparent: true,
                opacity: 0.9
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            console.log("âœ“ åŒå±‚å‘å…‰åœ£è¯æ ‘ç²’å­åˆ›å»ºå®Œæˆ");
        }

        function createPhantomTree() {
            // ä½¿ç”¨InstancedMeshåˆ›å»ºç²‰è‰²æ¸å˜å¹»å½±æ ‘
            const baseGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const phantomMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF69B4,
                emissive: 0xFF1493,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.4,
                roughness: 0.3,
                metalness: 0.1
            });
            
            phantomTreeInstances = new THREE.InstancedMesh(baseGeometry, phantomMaterial, PHANTOM_COUNT);
            const dummy = new THREE.Object3D();
            const colors = [];
            
            for(let i = 0; i < PHANTOM_COUNT; i++) {
                const r = i / PHANTOM_COUNT;
                const y = r * TREE_H - TREE_H/2;
                const radius = (TREE_R * 0.6) * (1 - r); // ç¨å°çš„åŠå¾„
                const angle = i * 0.4;
                
                dummy.position.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                dummy.scale.setScalar(0.7);
                dummy.updateMatrix();
                phantomTreeInstances.setMatrixAt(i, dummy.matrix);
                
                // é¡¶ç‚¹é¢œè‰²æ¸å˜ï¼šä¸Šäº®ä¸‹æš—
                const topBrightness = 0.9;
                const bottomBrightness = 0.3;
                const brightness = topBrightness - (topBrightness - bottomBrightness) * r;
                colors.push(brightness, brightness * 0.7, brightness * 0.9, 1.0);
            }
            
            // è®¾ç½®å®ä¾‹é¢œè‰²
            const colorAttribute = new THREE.InstancedBufferAttribute(new Float32Array(colors), 4);
            phantomTreeInstances.geometry.setAttribute('instanceColor', colorAttribute);
            
            // åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ä½¿ç”¨å®ä¾‹é¢œè‰²
            phantomTreeInstances.material.onBeforeCompile = (shader) => {
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <color_vertex>',
                    `#include <color_vertex>
                    vColor = instanceColor;`
                );
                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <color_fragment>',
                    `#include <color_fragment>
                    gl_FragColor = vec4(vColor.rgb * diffuseColor.rgb, opacity);`
                );
            };
            
            scene.add(phantomTreeInstances);
            console.log("âœ“ InstancedMeshæ¸å˜å¹»å½±æ ‘åˆ›å»ºå®Œæˆ");
        }

        function updateParticles(time) {
            const positions = particles.geometry.attributes.position.array;
            const treeTargets = particles.geometry.attributes.treeTarget.array;
            const heartTargets = particles.geometry.attributes.heartTarget.array;
            
            for(let i = 0; i < P_COUNT; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                
                let targetX, targetY, targetZ;
                
                if (state === 'heart' || state === 'love') {
                    // çˆ±å¿ƒå½¢æ€
                    targetX = heartTargets[ix];
                    targetY = heartTargets[iy];
                    targetZ = heartTargets[iz];
                } else if (state === 'firework' || state === 'pinch') {
                    // æ•£å¼€çŠ¶æ€
                    targetX = positions[ix] + (Math.random()-0.5)*0.2;
                    targetY = positions[iy] + (Math.random()-0.5)*0.2;
                    targetZ = positions[iz] + (Math.random()-0.5)*0.2;
                } else {
                    // åœ£è¯æ ‘å½¢æ€ï¼ˆå¸¦æ—‹è½¬ï¼‰
                    const angle = time * 0.15;
                    const x0 = treeTargets[ix], z0 = treeTargets[iz];
                    targetX = x0 * Math.cos(angle) - z0 * Math.sin(angle);
                    targetY = treeTargets[iy];
                    targetZ = x0 * Math.sin(angle) + z0 * Math.cos(angle);
                }
                
                // å¹³æ»‘è¿‡æ¸¡
                positions[ix] += (targetX - positions[ix]) * 0.08;
                positions[iy] += (targetY - positions[iy]) * 0.08;
                positions[iz] += (targetZ - positions[iz]) * 0.08;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            // æ›´æ–°å¹»å½±æ ‘æ—‹è½¬
            if (phantomTreeInstances) {
                phantomTreeInstances.rotation.y += sceneRotationSpeed;
                // é€æ˜åº¦æ³¢åŠ¨
                const opacity = 0.3 + Math.sin(time * 2) * 0.1;
                phantomTreeInstances.material.opacity = opacity;
            }
        }

        // === 4. ç…§ç‰‡ç³»ç»Ÿï¼ˆå‡åŒ€åˆ†å¸ƒ + æåˆèšç„¦ï¼‰===
        function loadPresetPhotos() {
            photoMeshGroup.clear();
            const loader = new THREE.TextureLoader();
            const photosLoaded = [];
            
            // è®¡ç®—å‡åŒ€åˆ†å¸ƒçš„è§’åº¦
            const angleStep = (Math.PI * 2) / PRESET_PHOTOS.length;
            
            PRESET_PHOTOS.forEach((fileName, index) => {
                loader.load(fileName, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    const aspect = texture.image.width / texture.image.height;
                    
                    // åŸºç¡€ç…§ç‰‡å°ºå¯¸ï¼ˆåœ¨æ ‘ä¸Šæ—¶çš„å¤§å°ï¼‰
                    const baseHeight = 3.5;
                    const baseWidth = baseHeight * aspect;
                    
                    const geometry = new THREE.PlaneGeometry(baseWidth, baseHeight);
                    const material = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    
                    // === å‡åŒ€åˆ†å¸ƒåœ¨åœ£è¯æ ‘å‘¨å›´ ===
                    // è®¡ç®—åœ¨æ ‘ä¸Šçš„ä½ç½®ï¼šæ ¹æ®ç…§ç‰‡æ•°é‡å‡åŒ€åˆ†é…é«˜åº¦å’Œè§’åº¦
                    const heightRatio = (index + 0.5) / PRESET_PHOTOS.length; // 0.5æ˜¯åç§»ï¼Œé¿å…æœ€ä½å’Œæœ€é«˜
                    const y = (heightRatio * TREE_H * 0.8) - (TREE_H * 0.4); // åˆ†å¸ƒåœ¨æ ‘é«˜åº¦çš„ä¸­é—´80%
                    
                    // åŠå¾„éšé«˜åº¦å‡å°ï¼ˆåœ†é”¥å½¢ï¼‰
                    const radiusAtHeight = TREE_R * (1 - heightRatio) + 3; // +3 è®©ç…§ç‰‡ç¦»æ ‘ç¨è¿œ
                    const angle = angleStep * index + Math.PI * 0.5; // ä»å‰æ–¹å¼€å§‹åˆ†å¸ƒ
                    
                    const treeX = Math.cos(angle) * radiusAtHeight;
                    const treeZ = Math.sin(angle) * radiusAtHeight;
                    
                    // ä¿å­˜æ ‘ä¸Šçš„ä½ç½®å’Œèšç„¦æ—¶çš„ç›®æ ‡ä½ç½®
                    mesh.userData = {
                        id: index,
                        treePosition: new THREE.Vector3(treeX, y, treeZ),
                        focusPosition: new THREE.Vector3(0, 0, 15), // èšç„¦æ—¶åœ¨ç›¸æœºå‰
                        baseScale: 1,
                        focusScale: 1,
                        aspect: aspect,
                        texture: texture,
                        title: `Memory ${index + 1}`
                    };
                    
                    mesh.position.copy(mesh.userData.treePosition);
                    mesh.lookAt(0, y, 0); // æœå‘æ ‘ä¸­å¿ƒ
                    
                    photoMeshGroup.add(mesh);
                    photosLoaded.push(mesh);
                    
                    // æ¸å…¥åŠ¨ç”»
                    setTimeout(() => {
                        material.opacity = 1;
                    }, 500 + index * 100);
                    
                    // æ‰€æœ‰ç…§ç‰‡åŠ è½½å®Œæˆåè®¡ç®—èšç„¦å°ºå¯¸
                    if (photosLoaded.length === PRESET_PHOTOS.length) {
                        calculateFocusProperties(photosLoaded);
                    }
                    
                }, undefined, (error) => {
                    console.error(`åŠ è½½ç…§ç‰‡å¤±è´¥ ${fileName}:`, error);
                    // åˆ›å»ºæ›¿ä»£çš„å½©è‰²æ–¹å—
                    createPhotoPlaceholder(index, angleStep);
                });
            });
            
            console.log("âœ“ ç…§ç‰‡ç³»ç»Ÿåˆå§‹åŒ–ï¼Œå‡åŒ€åˆ†å¸ƒåœ¨åœ£è¯æ ‘ä¸Š");
        }

        function calculateFocusProperties(photos) {
            // è®¡ç®—èšç„¦æ—¶ç…§ç‰‡çš„åˆé€‚å°ºå¯¸ï¼ˆå±å¹•é«˜åº¦çš„70%ï¼‰
            const screenHeight = window.innerHeight;
            const worldHeight = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * 15; // åœ¨z=15å¤„çš„ä¸–ç•Œé«˜åº¦
            const targetScreenHeightRatio = 0.7;
            const targetWorldHeight = worldHeight * targetScreenHeightRatio;
            
            photos.forEach(mesh => {
                const aspect = mesh.userData.aspect;
                const focusHeight = targetWorldHeight;
                const focusWidth = focusHeight * aspect;
                
                // æ£€æŸ¥å®½åº¦æ˜¯å¦åˆé€‚ï¼ˆä¸è¶…è¿‡å±å¹•å®½åº¦çš„80%ï¼‰
                const worldWidth = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * 15 * camera.aspect;
                const maxWidth = worldWidth * 0.8;
                
                if (focusWidth > maxWidth) {
                    // è°ƒæ•´åˆ°åˆé€‚å®½åº¦
                    mesh.userData.focusScale = maxWidth / (mesh.geometry.parameters.width * mesh.userData.baseScale);
                } else {
                    mesh.userData.focusScale = focusHeight / mesh.geometry.parameters.height;
                }
                
                // è®¡ç®—èšç„¦æ—¶çš„å‡†ç¡®ä½ç½®ï¼ˆç¡®ä¿åœ¨è§†å£ä¸­å±…ä¸­ï¼‰
                mesh.userData.focusPosition.z = 15; // å›ºå®šè·ç¦»
            });
        }

        function createPhotoPlaceholder(index, angleStep) {
            const colors = [0xFF69B4, 0xD4AF37, 0x6495ED, 0x4CAF50, 0x9C27B0];
            const color = colors[index % colors.length];
            
            const geometry = new THREE.PlaneGeometry(3, 3);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // åŒæ ·å‡åŒ€åˆ†å¸ƒ
            const heightRatio = (index + 0.5) / PRESET_PHOTOS.length;
            const y = (heightRatio * TREE_H * 0.8) - (TREE_H * 0.4);
            const radiusAtHeight = TREE_R * (1 - heightRatio) + 3;
            const angle = angleStep * index + Math.PI * 0.5;
            
            mesh.userData = {
                id: index,
                treePosition: new THREE.Vector3(Math.cos(angle) * radiusAtHeight, y, Math.sin(angle) * radiusAtHeight),
                focusPosition: new THREE.Vector3(0, 0, 15),
                baseScale: 1,
                focusScale: 1.5,
                aspect: 1,
                texture: null,
                title: `Placeholder ${index + 1}`,
                isPlaceholder: true
            };
            
            mesh.position.copy(mesh.userData.treePosition);
            mesh.lookAt(0, y, 0);
            photoMeshGroup.add(mesh);
            
            setTimeout(() => {
                material.opacity = 1;
            }, 500 + index * 100);
        }

        function updatePhotos() {
            if (isPhotoFocused) return; // èšç„¦æ¨¡å¼ä¸‹ä¸æ›´æ–°æ ‘ä¸Šçš„ä½ç½®
            
            photoMeshGroup.children.forEach((mesh, index) => {
                const userData = mesh.userData;
                const time = clock.getElapsedTime();
                
                if (state === 'tree') {
                    // æ­£å¸¸æ˜¾ç¤ºåœ¨æ ‘ä¸Šï¼Œç¼“æ…¢æ—‹è½¬
                    const targetPos = userData.treePosition.clone();
                    
                    // æ·»åŠ è½»å¾®çš„æµ®åŠ¨åŠ¨ç”»
                    targetPos.y += Math.sin(time * 0.5 + index) * 0.3;
                    
                    // éšæ•´ä½“åœºæ™¯æ—‹è½¬
                    const angle = time * 0.1;
                    const x = targetPos.x * Math.cos(angle) - targetPos.z * Math.sin(angle);
                    const z = targetPos.x * Math.sin(angle) + targetPos.z * Math.cos(angle);
                    targetPos.x = x;
                    targetPos.z = z;
                    
                    mesh.position.lerp(targetPos, 0.05);
                    
                    // æœå‘ç›¸æœºä½†ç•¥å¾®æœå‘æ ‘ä¸­å¿ƒ
                    const lookAtPos = new THREE.Vector3(0, targetPos.y * 0.7, 0);
                    mesh.lookAt(lookAtPos);
                    
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, userData.baseScale, 0.1));
                    mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, 1, 0.1);
                    
                } else if (state === 'firework') {
                    // æ•£å¼€çŠ¶æ€
                    mesh.position.y += Math.sin(time * 2 + index) * 0.05;
                    mesh.rotation.y += 0.02;
                    mesh.scale.setScalar(THREE.MathUtils.lerp(mesh.scale.x, 0.8, 0.1));
                    mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, 0.7, 0.1);
                    
                } else {
                    // å…¶ä»–çŠ¶æ€ä¸‹æ·¡å‡º
                    mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, 0, 0.1);
                }
            });
        }

        // === 5. æåˆèšç„¦åŠŸèƒ½ ===
        function findClosestPhotoToScreenCenter() {
            if (photoMeshGroup.children.length === 0) return null;
            
            const screenCenter = new THREE.Vector2(0, 0);
            let closestPhoto = null;
            let closestDistance = Infinity;
            
            photoMeshGroup.children.forEach(mesh => {
                // å°†3Dä½ç½®è½¬æ¢ä¸ºå±å¹•åæ ‡
                const worldPosition = mesh.getWorldPosition(new THREE.Vector3());
                const screenPosition = worldToScreen(worldPosition);
                
                // è®¡ç®—åˆ°å±å¹•ä¸­å¿ƒçš„è·ç¦»
                const distance = screenPosition.distanceTo(screenCenter);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPhoto = mesh;
                }
            });
            
            return closestPhoto;
        }

        function worldToScreen(worldPos) {
            const vector = worldPos.clone();
            vector.project(camera);
            
            return new THREE.Vector2(
                (vector.x * 0.5 + 0.5) * window.innerWidth,
                (-vector.y * 0.5 + 0.5) * window.innerHeight
            );
        }

        function focusOnPhoto(photoMesh) {
            if (!photoMesh || isPhotoFocused) return;
            
            isPhotoFocused = true;
            currentSelectedPhoto = photoMesh;
            
            // ä¿å­˜åŸå§‹ç›¸æœºçŠ¶æ€
            originalCameraPosition.copy(camera.position);
            originalCameraRotation.copy(camera.rotation);
            
            // æ˜¾ç¤ºèšç„¦é®ç½©
            const overlay = document.getElementById('photo-focus-overlay');
            const titleEl = document.getElementById('focused-photo-title');
            titleEl.textContent = photoMesh.userData.title || "Memory";
            overlay.style.display = 'flex';
            
            // åˆ›å»ºèšç„¦è§†å›¾çš„ç…§ç‰‡å‰¯æœ¬ï¼ˆç¡®ä¿åœ¨é®ç½©ä¸Šå±‚ï¼‰
            const focusGeometry = photoMesh.geometry.clone();
            let focusMaterial;
            
            if (photoMesh.userData.isPlaceholder) {
                focusMaterial = photoMesh.material.clone();
            } else {
                focusMaterial = new THREE.MeshBasicMaterial({
                    map: photoMesh.userData.texture,
                    side: THREE.DoubleSide,
                    transparent: true
                });
            }
            
            const focusPhoto = new THREE.Mesh(focusGeometry, focusMaterial);
            focusPhoto.scale.setScalar(photoMesh.userData.focusScale * 0.1); // åˆå§‹å¾ˆå°
            
            // å°†ç…§ç‰‡æ·»åŠ åˆ°é®ç½©å®¹å™¨ï¼ˆé€šè¿‡è‡ªå®šä¹‰æ¸²æŸ“æˆ–ä½¿ç”¨ç¬¬äºŒä¸ªåœºæ™¯ï¼‰
            // è¿™é‡Œç®€åŒ–ï¼šç›´æ¥ç§»åŠ¨åŸå§‹ç…§ç‰‡å¹¶è°ƒæ•´ç›¸æœº
            
            // è®¡ç®—ç»å¯¹å±…ä¸­çš„ä½ç½®ï¼ˆä¸é¡¶éƒ¨æ ‡é¢˜ã€åº•éƒ¨æŒ‰é’®åŒè½´ï¼‰
            const targetPosition = new THREE.Vector3(0, 0, 15);
            
            // æ­£è§†å›¾é”å®šï¼šè°ƒæ•´ç›¸æœºä½ç½®ä½¿ç…§ç‰‡å¹³è¡Œäºå±å¹•
            const photoWorldPos = photoMesh.getWorldPosition(new THREE.Vector3());
            const cameraTargetPos = photoWorldPos.clone();
            cameraTargetPos.z += 15; // ç›¸æœºåœ¨ç…§ç‰‡å‰æ–¹
            
            // å¹³æ»‘è¿‡æ¸¡åˆ°èšç„¦è§†å›¾
            const focusAnimation = {
                startTime: clock.getElapsedTime(),
                duration: 0.8,
                originalPhotoPos: photoMesh.position.clone(),
                originalCameraPos: camera.position.clone(),
                targetPhotoPos: targetPosition,
                targetCameraPos: cameraTargetPos
            };
            
            photoMesh.userData.focusAnimation = focusAnimation;
            photoMesh.userData.isFocusing = true;
            
            // éšè—å…¶ä»–ç…§ç‰‡
            photoMeshGroup.children.forEach(mesh => {
                if (mesh !== photoMesh) {
                    mesh.userData.originalOpacity = mesh.material.opacity;
                }
            });
            
            console.log("èšç„¦ç…§ç‰‡:", photoMesh.userData.title);
        }

        function updatePhotoFocus() {
            if (!currentSelectedPhoto || !currentSelectedPhoto.userData.isFocusing) return;
            
            const anim = currentSelectedPhoto.userData.focusAnimation;
            const elapsed = clock.getElapsedTime() - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);
            
            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
            const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
            const t = easeOutCubic(progress);
            
            // ç…§ç‰‡ä½ç½®æ’å€¼
            currentSelectedPhoto.position.lerpVectors(anim.originalPhotoPos, anim.targetPhotoPos, t);
            
            // ç›¸æœºä½ç½®æ’å€¼
            camera.position.lerpVectors(anim.originalCameraPos, anim.targetCameraPos, t);
            
            // ç…§ç‰‡ç¼©æ”¾æ’å€¼
            const targetScale = currentSelectedPhoto.userData.focusScale;
            currentSelectedPhoto.scale.setScalar(THREE.MathUtils.lerp(1, targetScale, t));
            
            // æ­£è§†å›¾é”å®šï¼šè®©ç…§ç‰‡å§‹ç»ˆé¢å‘ç›¸æœº
            currentSelectedPhoto.lookAt(camera.position);
            
            // éšè—å…¶ä»–ç…§ç‰‡
            photoMeshGroup.children.forEach(mesh => {
                if (mesh !== currentSelectedPhoto) {
                    mesh.material.opacity = THREE.MathUtils.lerp(
                        mesh.userData.originalOpacity || 1, 
                        0.1, 
                        t
                    );
                }
            });
            
            if (progress >= 1) {
                currentSelectedPhoto.userData.isFocusing = false;
                // èšç„¦å®Œæˆ
                currentSelectedPhoto.material.opacity = 1;
            }
        }

        function exitPhotoFocus() {
            if (!isPhotoFocused) return;
            
            isPhotoFocused = false;
            
            // éšè—é®ç½©
            document.getElementById('photo-focus-overlay').style.display = 'none';
            
            // æ¢å¤å…¶ä»–ç…§ç‰‡çš„é€æ˜åº¦
            photoMeshGroup.children.forEach(mesh => {
                if (mesh !== currentSelectedPhoto) {
                    mesh.material.opacity = mesh.userData.originalOpacity || 1;
                }
            });
            
            if (currentSelectedPhoto) {
                // æ¢å¤åŠ¨ç”»
                const restoreAnim = {
                    startTime: clock.getElapsedTime(),
                    duration: 0.6,
                    startPos: currentSelectedPhoto.position.clone(),
                    startScale: currentSelectedPhoto.scale.x,
                    startCameraPos: camera.position.clone()
                };
                
                currentSelectedPhoto.userData.restoreAnimation = restoreAnim;
                currentSelectedPhoto.userData.isRestoring = true;
                currentSelectedPhoto.userData.isFocusing = false;
            }
            
            console.log("é€€å‡ºç…§ç‰‡èšç„¦");
        }

        function updatePhotoRestore() {
            if (!currentSelectedPhoto || !currentSelectedPhoto.userData.isRestoring) return;
            
            const anim = currentSelectedPhoto.userData.restoreAnimation;
            const elapsed = clock.getElapsedTime() - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);
            
            const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
            const t = easeOutCubic(progress);
            
            // æ¢å¤ç…§ç‰‡ä½ç½®å’Œç¼©æ”¾
            const targetPos = currentSelectedPhoto.userData.treePosition || new THREE.Vector3(0, 0, 10);
            currentSelectedPhoto.position.lerpVectors(anim.startPos, targetPos, t);
            
            currentSelectedPhoto.scale.setScalar(THREE.MathUtils.lerp(anim.startScale, 1, t));
            
            // æ¢å¤ç›¸æœºä½ç½®
            camera.position.lerpVectors(anim.startCameraPos, originalCameraPosition, t);
            camera.rotation.copy(originalCameraRotation);
            
            // æ¢å¤æœå‘
            if (progress > 0.5) {
                const lookAtY = currentSelectedPhoto.position.y * 0.7;
                currentSelectedPhoto.lookAt(new THREE.Vector3(0, lookAtY, 0));
            }
            
            if (progress >= 1) {
                currentSelectedPhoto.userData.isRestoring = false;
                currentSelectedPhoto = null;
                state = 'tree'; // æ¢å¤é»˜è®¤çŠ¶æ€
            }
        }

        // ç»‘å®šå…³é—­æŒ‰é’®
        document.getElementById('close-focus-btn').addEventListener('click', exitPhotoFocus);

        // === 6. æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿï¼ˆä¿®å¤ç‰ˆï¼‰===
        async function initHandTracking() {
            return new Promise((resolve, reject) => {
                // MediaPipeé€šè¿‡scriptæ ‡ç­¾å·²å…¨å±€åŠ è½½ï¼Œç›´æ¥ä½¿ç”¨
                if (!window.vision) {
                    // å¦‚æœå…¨å±€åŠ è½½å¤±è´¥ï¼ŒåŠ¨æ€åŠ è½½
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm/vision_bundle.js';
                    script.onload = async () => {
                        try {
                            await initializeHandLandmarker();
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    };
                    script.onerror = () => reject(new Error("MediaPipeè„šæœ¬åŠ è½½å¤±è´¥"));
                    document.head.appendChild(script);
                } else {
                    initializeHandLandmarker().then(resolve).catch(reject);
                }
            });
        }

        async function initializeHandLandmarker() {
            const vision = window.vision;
            if (!vision) throw new Error("visionå¯¹è±¡æœªå®šä¹‰");
            
            const filesetResolver = vision.FilesetResolver;
            const HandLandmarker = vision.HandLandmarker;
            
            const visionInstance = await filesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(visionInstance, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2,
                minHandDetectionConfidence: 0.5,
                minHandPresenceConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            console.log("âœ“ MediaPipe æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–æˆåŠŸ");
        }

        async function startCamera() {
            const video = document.getElementById("camera-preview");
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: "user",
                        width: { ideal: 480 },
                        height: { ideal: 360 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                video.srcObject = stream;
                await new Promise(resolve => video.onloadeddata = resolve);
                video.play();
                webcamRunning = true;
                
                console.log("âœ“ æ‘„åƒå¤´å¯åŠ¨æˆåŠŸï¼Œå¼€å§‹æ‰‹åŠ¿æ£€æµ‹");
                detectGestureLoop();
                
            } catch (error) {
                console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", error);
                document.getElementById('gesture-guide').innerHTML = 
                    '<div style="color:#ff5555;">æ‘„åƒå¤´ä¸å¯ç”¨<br>è¯·ä½¿ç”¨æ‰‹åŠ¨æµ‹è¯•</div>';
            }
        }

        function detectGestureLoop() {
            if (!handLandmarker || !webcamRunning) return;
            
            const video = document.getElementById("camera-preview");
            if (video.currentTime === lastVideoTime) {
                requestAnimationFrame(detectGestureLoop);
                return;
            }
            
            lastVideoTime = video.currentTime;
            
            try {
                const results = handLandmarker.detectForVideo(video, performance.now());
                processGestures(results);
            } catch (error) {
                console.warn("æ‰‹åŠ¿æ£€æµ‹å‡ºé”™:", error);
            }
            
            requestAnimationFrame(detectGestureLoop);
        }

        function processGestures(results) {
            if (isPhotoFocused) return; // èšç„¦æ¨¡å¼ä¸‹ä¸å¤„ç†æ‰‹åŠ¿
            
            const guideItems = document.querySelectorAll('.g-item');
            guideItems.forEach(item => item.classList.remove('active'));
            
            let newState = 'tree';
            let activeUI = 'g-tree';
            let newClench = 0;
            let detectedPinch = false;
            
            if (results.landmarks && results.landmarks.length > 0) {
                const hand = results.landmarks[0];
                
                // è®¡ç®—æ‰‹æŒç§»åŠ¨é€Ÿåº¦
                if (hand[9]) {
                    const dx = hand[9].x - lastHandX;
                    if (Math.abs(dx) > 0.01) handVelocityX = dx * -5;
                    lastHandX = hand[9].x;
                }
                
                // å•æ‰‹åŠ¿è¯†åˆ«
                const wrist = hand[0];
                const tips = [8, 12, 16, 20];
                let totalDist = 0;
                
                tips.forEach(tipIndex => {
                    const tip = hand[tipIndex];
                    const dist = Math.sqrt(
                        Math.pow(tip.x - wrist.x, 2) + 
                        Math.pow(tip.y - wrist.y, 2)
                    );
                    totalDist += dist;
                });
                
                const avgDist = totalDist / tips.length;
                
                // æåˆæ£€æµ‹ï¼šæ‹‡æŒ‡å°–(4)å’Œé£ŸæŒ‡å°–(8)çš„è·ç¦»
                const thumbTip = hand[4];
                const indexTip = hand[8];
                const pinchDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                // æ‰‹åŠ¿å†³ç­–é€»è¾‘
                if (avgDist < 0.22) {
                    newState = 'heart';
                    activeUI = 'g-fist';
                    newClench = 1;
                } else if (avgDist > 0.35) {
                    newState = 'firework';
                    activeUI = 'g-burst';
                    newClench = 0;
                    
                    // åœ¨å¼ æ‰‹çŠ¶æ€ä¸‹æ£€æµ‹æåˆ
                    if (pinchDist < 0.08) {
                        detectedPinch = true;
                        newState = 'pinch';
                        activeUI = 'g-pinch';
                        newClench = 0.5;
                    }
                } else if (avgDist > 0.22 && avgDist <= 0.35) {
                    newState = 'tree';
                    activeUI = 'g-tree';
                    newClench = 0;
                }
                
                // åŒæ‰‹æ£€æµ‹
                if (results.landmarks.length === 2) {
                    const hand1 = results.landmarks[0];
                    const hand2 = results.landmarks[1];
                    
                    // æ£€æµ‹åŒæ‰‹çˆ±å¿ƒæ‰‹åŠ¿ï¼ˆåŒæ‰‹æŒ‡å°–é è¿‘ï¼‰
                    const h1Tip = hand1[8], h2Tip = hand2[8];
                    const h1Thumb = hand1[4], h2Thumb = hand2[4];
                    
                    const tipsDistance = Math.sqrt(
                        Math.pow(h1Tip.x - h2Tip.x, 2) + 
                        Math.pow(h1Tip.y - h2Tip.y, 2)
                    );
                    
                    const thumbsDistance = Math.sqrt(
                        Math.pow(h1Thumb.x - h2Thumb.x, 2) + 
                        Math.pow(h1Thumb.y - h2Thumb.y, 2)
                    );
                    
                    if (tipsDistance < 0.1 && thumbsDistance < 0.1) {
                        newState = 'love';
                        activeUI = 'g-love';
                    }
                }
            } else {
                handVelocityX *= 0.9;
            }
            
            // åº”ç”¨çŠ¶æ€å˜åŒ–
            state = newState;
            document.getElementById(activeUI).classList.add('active');
            handClench += (newClench - handClench) * 0.1;
            
            // æ˜¾ç¤º/éšè—çˆ±å¿ƒå¼¹çª—
            const messageBox = document.getElementById('custom-message-box');
            messageBox.style.display = (state === 'love') ? 'block' : 'none';
            
            // æåˆè§¦å‘ç…§ç‰‡èšç„¦
            if (detectedPinch && !isPhotoFocused) {
                const closestPhoto = findClosestPhotoToScreenCenter();
                if (closestPhoto) {
                    focusOnPhoto(closestPhoto);
                }
            }
            
            // æ›´æ–°åœºæ™¯æ—‹è½¬é€Ÿåº¦
            if (state === 'firework' || state === 'pinch') {
                sceneRotationSpeed = handVelocityX * 0.3;
            } else {
                sceneRotationSpeed = 0.002;
            }
        }

        // === 7. åŠ¨ç”»å¾ªç¯ ===
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // æ›´æ–°æ‰‹åŠ¿æ£€æµ‹ï¼ˆå·²åœ¨ç‹¬ç«‹å¾ªç¯ä¸­ï¼‰
            
            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            updateParticles(elapsedTime);
            
            // æ›´æ–°ç…§ç‰‡
            if (isPhotoFocused) {
                updatePhotoFocus();
            } else if (currentSelectedPhoto && currentSelectedPhoto.userData.isRestoring) {
                updatePhotoRestore();
            } else {
                updatePhotos();
            }
            
            // åœºæ™¯æ—‹è½¬
            if (!isPhotoFocused) {
                if (particles) particles.rotation.y += sceneRotationSpeed;
                if (phantomTreeInstances) phantomTreeInstances.rotation.y += sceneRotationSpeed;
                if (photoMeshGroup) photoMeshGroup.rotation.y += sceneRotationSpeed * 0.7;
            }
            
            // é¡¶éƒ¨æ˜Ÿæ˜Ÿ
            if (topStar && state === 'tree') {
                topStar.visible = true;
                topStar.rotation.y += 0.02;
                topStar.position.y = TREE_H/2 + 1 + Math.sin(elapsedTime) * 0.3;
            } else if (topStar) {
                topStar.visible = false;
            }
            
            // å¹»å½±æ ‘æ˜¾ç¤º
            if (phantomTreeInstances) {
                phantomTreeInstances.visible = (state === 'tree');
            }
            
            // "mm"æ–‡å­—
            if (mmTextSprite) {
                const targetOpacity = (state === 'heart' || state === 'love') ? 1 : 0;
                mmTextSprite.material.opacity = THREE.MathUtils.lerp(
                    mmTextSprite.material.opacity, 
                    targetOpacity, 
                    0.1
                );
            }
            
            // æ›´æ–°è§’è‰²
            updateCharacter();
            
            // æ›´æ–°é›ª
            updateSnow(deltaTime);
            
            // æ›´æ–°çŒæˆ·åº§é—ªçƒ
            updateOrionStars(elapsedTime);
            
            // æ¸²æŸ“
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // [åŸæœ‰çš„è¾…åŠ©å‡½æ•°å¦‚ createNaturalNebula, createOrion, createTopStar, createSnow, 
        // createMMText, updateCharacter, updateSnow, updateOrionStars, initAudio ç­‰éœ€è¦ä¿ç•™]
        // ç”±äºç¯‡å¹…é™åˆ¶ï¼Œè¿™äº›å‡½æ•°æœªåœ¨æ­¤å¤„é‡å¤ï¼Œä½†åº”åŒ…å«åœ¨ä½ çš„ä»£ç ä¸­

        // === 8. å…¶ä»–åŠŸèƒ½ ===
        window.switchModel = function(name) {
            loadModel(name);
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#controls .btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        function loadModel(name) {
            if (!MODELS[name]) return;
            
            const loader = new THREE.MMDLoader();
            loader.load(MODELS[name], (model) => {
                if (currentModel) scene.remove(currentModel);
                
                currentModel = model;
                model.position.set(-15, -12, -5);
                model.rotation.y = 0.5;
                model.scale.setScalar(0.85);
                
                // å¤„ç†æè´¨
                if (model.material) {
                    const materials = Array.isArray(model.material) ? model.material : [model.material];
                    materials.forEach(material => {
                        material.emissive = new THREE.Color(0x222222);
                        if (name === 'usagi') material.color.setHex(0xFFEEAA);
                        if (name === 'chiikawa') material.color.setHex(0xFFCCDD);
                        material.needsUpdate = true;
                    });
                }
                
                scene.add(model);
                console.log(`âœ“ è§’è‰²æ¨¡å‹åŠ è½½: ${name}`);
            });
        }

        function updateCharacter() {
            if (!currentModel || !currentModel.skeleton) return;
            
            const bones = currentModel.skeleton.bones;
            const leftWrist = bones.find(b => b.name && b.name.includes('å·¦è…•'));
            const rightWrist = bones.find(b => b.name && b.name.includes('å³è…•'));
            
            if (leftWrist && rightWrist) {
                leftWrist.rotation.z = THREE.MathUtils.lerp(-0.5, 0.8, handClench);
                leftWrist.rotation.x = THREE.MathUtils.lerp(0, -0.5, handClench);
                rightWrist.rotation.z = -leftWrist.rotation.z;
                rightWrist.rotation.x = leftWrist.rotation.x;
            }
        }

        // é”™è¯¯å¤„ç†
        function showError(msg) {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.innerHTML = `
                    <div style="color:#ff5555; text-align:center; padding:20px;">
                        <h3>åˆå§‹åŒ–å¤±è´¥</h3>
                        <p>${msg}</p>
                        <button onclick="location.reload()" class="btn" style="margin-top:20px; background:#ff5555;">
                            ç‚¹å‡»é‡è¯•
                        </button>
                    </div>
                `;
            }
            console.error(msg);
        }

        // ç§»åŠ¨ç«¯è§¦æ‘¸æ”¯æŒ
        document.addEventListener('touchstart', function(e) {
            // é˜²æ­¢é¡µé¢æ»šåŠ¨
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
            }
        }, { passive: false });

        console.log("ğŸ„ Sylvan Echo Christmas äº¤äº’é¡µé¢å·²åˆå§‹åŒ–");
        console.log("æ‰‹åŠ¿æ§åˆ¶è¯´æ˜:");
        console.log("1. æ¡æ‹³: çˆ±å¿ƒå½¢æ€");
        console.log("2. å¼ æ‰‹: æ•£å¼€å½¢æ€");
        console.log("3. å¼ æ‰‹+æåˆ: èšç„¦ç…§ç‰‡");
        console.log("4. åŒæ‰‹é è¿‘: çˆ±å¿ƒå¼¹çª—");
    </script>
</body>
</html>
