<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Christmas Magic: Aurora Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "Helvetica Neue", sans-serif; }
        #container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* 1. 顶部标题 (更精致的字体) */
        #top-title {
            position: absolute; top: 8vh; width: 100%; text-align: center;
            font-family: 'Cinzel', serif; /* 类似电影海报字体 */
            font-size: 2.5rem; letter-spacing: 4px; font-weight: 600;
            background: linear-gradient(to bottom, #fff, #ffd700);
            -webkit-background-clip: text; color: transparent;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.5));
            z-index: 10; pointer-events: none; transition: opacity 0.5s;
        }

        /* 2. 调试面板 (半透明) */
        #debug-panel {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(4px);
            padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            color: #00ff00; font-family: monospace; font-size: 10px;
            pointer-events: none; text-align: left; min-width: 100px;
        }

        /* 3. 启动遮罩 */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; transition: opacity 0.8s ease-out;
        }
        #loading-text { margin-bottom: 20px; color: #aaa; font-size: 12px; letter-spacing: 2px; }
        #start-btn {
            padding: 12px 40px; font-size: 1rem; background: transparent; 
            border: 1px solid rgba(255,215,0,0.5); color: #ffd700;
            border-radius: 30px; cursor: not-allowed; transition: 0.3s;
            text-transform: uppercase; letter-spacing: 2px;
        }
        #start-btn.ready {
            background: rgba(255,215,0,0.1); border-color: #ffd700; color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2); cursor: pointer;
        }
        #start-btn.ready:hover { background: rgba(255,215,0,0.3); transform: scale(1.05); }

        /* 4. 许愿弹窗 */
        #message-box {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: auto; padding: 30px 50px;
            background: rgba(10, 10, 20, 0.85); backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 4px;
            color: #fff; font-family: 'Georgia', serif; font-size: 1.5rem; text-align: center;
            box-shadow: 0 0 60px rgba(0,0,0, 0.8);
            display: none; z-index: 30; letter-spacing: 1px;
        }

        /* 5. 底部按钮 */
        #ui-layer {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            text-align: center; z-index: 10; pointer-events: none;
        }
        .btn-group {
            pointer-events: auto; background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px); padding: 5px; border-radius: 50px;
            display: inline-block; border: 1px solid rgba(255,255,255,0.05);
        }
        button.model-btn {
            background: transparent; color: rgba(255,255,255,0.5);
            border: none; padding: 8px 24px; margin: 0;
            border-radius: 40px; font-size: 12px; transition: 0.3s; cursor: pointer;
        }
        button.model-btn.active { background: rgba(255,255,255,0.15); color: #fff; font-weight: 600; }
        
        #video-preview {
            position: absolute; top: 0; left: 0; width: 1px; height: 1px;
            opacity: 0; pointer-events: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-family: 'Cinzel', serif; font-size: 2.5rem; color: #ffd700; text-shadow:0 0 20px rgba(255,215,0,0.5);">Winter Solstice</h1>
        <div id="loading-text">INITIALIZING MAGIC...</div>
        <button id="start-btn" disabled>LOADING</button>
    </div>

    <div id="top-title">Merry Christmas</div>

    <div id="debug-panel">
        <div>Hand: <span id="debug-hand">--</span></div>
        <div>Mode: <span id="debug-state">Auto</span></div>
        <div>Color: <span id="debug-color">Gold</span></div>
    </div>
    
    <div id="message-box">
        ✨ Make a Wish ✨
    </div>

    <video id="video-preview" playsinline webkit-playsinline muted autoplay></video>

    <div id="ui-layer">
        <div class="btn-group">
            <button onclick="switchModel('hachiware')" id="btn-hachiware" class="model-btn active">Hachiware</button>
            <button onclick="switchModel('usagi')" id="btn-usagi" class="model-btn">Usagi</button>
            <button onclick="switchModel('chiikawa')" id="btn-chiikawa" class="model-btn">Chiikawa</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm';

        // --- 全局变量 ---
        let scene, camera, renderer, controls;
        let mainGroup; // 包含树、流光、星星的组
        let auroraMesh; // 极光网格
        let starField;  // 背景星星
        let snowSystem; // 雪花系统
        
        let ornaments = [];
        let flowParticles = []; 
        let starMesh; 
        let currentModel = null, currentModelName = 'hachiware';
        
        // 材质引用 (颜色同步核心)
        let matMain;   // 主体宝石材质
        let matGlow;   // 内部发光材质
        let matFlow;   // 粒子流材质
        let matSnow;   // 雪花材质
        let matStar;   // 顶部星星材质
        
        // 交互与动画状态
        let targetShape = 'tree'; // tree, ball, explode
        let shapeLerpFactor = 0;  // 0=Tree, 1=Ball
        let handClenchLevel = 0;
        let isHandDetected = false;
        let previousHandX = 0;
        
        // 颜色状态
        let colorState = 0; 
        let lastWaveTime = 0;
        const COLORS = {
            0: { name: 'Champagne Gold', main: 0xffd700, emissive: 0xffaa00, snow: 0xffffff, flow: 0xfff8e7, aurora: new THREE.Vector3(0.1, 0.8, 0.5) },
            1: { name: 'Glacial Blue',   main: 0x00dfff, emissive: 0x0055ff, snow: 0xddeeff, flow: 0xccffff, aurora: new THREE.Vector3(0.0, 0.4, 1.0) },
            2: { name: 'Sakura Pink',    main: 0xff99cc, emissive: 0xff1493, snow: 0xffe6f2, flow: 0xffcce6, aurora: new THREE.Vector3(1.0, 0.4, 0.6) }
        };

        // 配置
        const TREE_HEIGHT = 22;
        const TREE_RADIUS_BASE = 9;
        const BALL_RADIUS = 7; // 聚合成球的半径
        const ORNAMENT_COUNT = 4500; // 积木数量
        const FLOW_COUNT = 600; // 流光粒子数量

        const MODELS = {
            'hachiware': './hachiware.pmx',
            'usagi': './usagi.pmx',
            'chiikawa': './chiikawa.pmx'
        };

        // DOM
        const startBtn = document.getElementById('start-btn');
        const loadingText = document.getElementById('loading-text');
        const debugHand = document.getElementById('debug-hand');
        const debugColor = document.getElementById('debug-color');
        const debugState = document.getElementById('debug-state');

        // --- Shader: 极光 (Aurora) ---
        const auroraVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const auroraFragmentShader = `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;
            
            // 简单的伪噪声函数
            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            void main() {
                // 极光波纹逻辑
                float n = noise(vec2(vUv.x * 5.0 + time * 0.1, vUv.y * 2.0 - time * 0.2));
                float n2 = noise(vec2(vUv.x * 8.0 - time * 0.15, vUv.y * 4.0 + time * 0.1));
                
                float strength = smoothstep(0.3, 0.7, n * n2 + 0.2);
                
                // 边缘淡出
                strength *= smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.6, vUv.y);
                
                gl_FragColor = vec4(color, strength * 0.4); 
            }
        `;

        init3D();
        preloadAI();

        startBtn.addEventListener('click', async () => {
            if (startBtn.disabled) return;
            startBtn.innerText = "LAUNCHING...";
            try {
                await startCamera();
                document.getElementById('start-overlay').style.opacity = '0';
                setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 800);
                animate();
            } catch (e) {
                alert("Camera Error: " + e);
            }
        });

        // --- 初始化场景 ---
        function init3D() {
            scene = new THREE.Scene();
            // 背景黑，主要靠极光和星星点缀
            scene.fog = new THREE.FogExp2(0x000000, 0.015);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 42); // 稍微拉近一点

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = false;
            controls.maxPolarAngle = Math.PI / 1.5; // 防止看地下

            // 灯光系统 (更具戏剧性)
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(10, 30, 20);
            scene.add(mainLight);
            
            // 底部冷光，增加立体感
            const bottomLight = new THREE.DirectionalLight(0x002244, 1.0);
            bottomLight.position.set(-10, -20, -10);
            scene.add(bottomLight);

            // 核心组
            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // 1. 极光 (背景)
            createAurora();
            // 2. 星星 (背景)
            createStars();
            // 3. 圣诞树/能量球主体 (核心)
            createCrystalTree(); 
            // 4. 粒子流 (特效)
            createSmartFlow(); 
            // 5. 顶部星星
            createTopStar();
            // 6. 雪花
            createMicroSnow(); 

            loadMMDModel('hachiware');

            // 窗口自适应
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            window.switchModel = (name) => {
                if (currentModelName === name) return;
                currentModelName = name;
                document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${name}`).classList.add('active');
                loadMMDModel(name);
            };
        }

        // --- 创建极光 ---
        function createAurora() {
            const geo = new THREE.PlaneGeometry(120, 80, 1, 1);
            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: COLORS[0].aurora } // 初始颜色
                },
                vertexShader: auroraVertexShader,
                fragmentShader: auroraFragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            auroraMesh = new THREE.Mesh(geo, mat);
            auroraMesh.position.set(0, 10, -30); // 放在树后面
            auroraMesh.rotation.x = -0.2; // 稍微倾斜
            scene.add(auroraMesh);
        }

        // --- 创建背景星星 ---
        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<1500; i++) {
                const r = 60 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                pos.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3, transparent: true, opacity: 0.8 });
            starField = new THREE.Points(geo, mat);
            scene.add(starField);
        }

        // --- 创建水晶树 (Mod: 自由发挥形态) ---
        function createCrystalTree() {
            // 几何体库：更像宝石
            const geoIco = new THREE.IcosahedronGeometry(0.25, 0); // 宝石球
            const geoOct = new THREE.OctahedronGeometry(0.2, 0);   // 尖锐宝石
            const geoCube = new THREE.BoxGeometry(0.2, 0.4, 0.2);  // 晶条

            // 材质：高光泽，强反射
            matMain = new THREE.MeshStandardMaterial({
                color: COLORS[0].main,
                emissive: COLORS[0].emissive,
                emissiveIntensity: 0.6,
                roughness: 0.1,
                metalness: 0.8,
            });
            
            // 内部发光体材质 (占20%)
            matGlow = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 2.0,
                toneMapped: false
            });

            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                // 1. 形状选择
                let mesh;
                const r = Math.random();
                if (r < 0.6) mesh = new THREE.Mesh(geoIco, matMain); // 60% 主宝石
                else if (r < 0.9) mesh = new THREE.Mesh(geoOct, matMain); // 30% 辅助宝石
                else mesh = new THREE.Mesh(geoCube, matGlow); // 10% 闪光核心
                
                // 随机缩放
                const s = 0.5 + Math.random() * 1.2;
                mesh.scale.setScalar(s);

                // 2. 计算树形态位置 (圆锥螺旋)
                const yNorm = i / ORNAMENT_COUNT; // 0 ~ 1
                const treeY = (yNorm * TREE_HEIGHT) - (TREE_HEIGHT / 2);
                const treeR = TREE_RADIUS_BASE * (1 - Math.pow(yNorm, 0.8)) + Math.random(); // 底部宽，顶部尖
                const treeAngle = i * 0.1 + Math.random() * 0.5; // 稍微随机
                const posTree = new THREE.Vector3(
                    Math.cos(treeAngle) * treeR,
                    treeY,
                    Math.sin(treeAngle) * treeR
                );

                // 3. 计算球形态位置 (斐波那契球体 - 均匀分布)
                // 黄金角度
                const phi = Math.acos(1 - 2 * (i + 0.5) / ORNAMENT_COUNT);
                const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
                
                // 球体稍微有点体积厚度
                const rShell = BALL_RADIUS + (Math.random() - 0.5) * 2; 
                const posBall = new THREE.Vector3(
                    rShell * Math.sin(phi) * Math.cos(theta),
                    rShell * Math.sin(phi) * Math.sin(theta), // 球心在 0,0,0
                    rShell * Math.cos(phi)
                );

                // 4. 爆炸向量
                const posExplode = posBall.clone().normalize().multiplyScalar(Math.random() * 30 + 10);

                // 初始位置
                mesh.position.copy(posTree);
                // 随机自转速度
                const rotSpeed = { x: Math.random()*0.02, y: Math.random()*0.02 };

                mainGroup.add(mesh);
                ornaments.push({
                    mesh: mesh,
                    posTree: posTree,
                    posBall: posBall,
                    dirExplode: posExplode, // 方向向量
                    rotSpeed: rotSpeed,
                    velocity: new THREE.Vector3(),
                    isGlow: r >= 0.9 // 标记是否是发光块
                });
            }
        }

        // --- 智能流光 (Mod: 随形而变) ---
        function createSmartFlow() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(FLOW_COUNT * 3);
            const phases = new Float32Array(FLOW_COUNT);
            const speeds = new Float32Array(FLOW_COUNT);

            for(let i=0; i<FLOW_COUNT; i++) {
                pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
                phases[i] = Math.random() * Math.PI * 2;
                speeds[i] = 0.5 + Math.random() * 1.0;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            matFlow = new THREE.PointsMaterial({
                color: COLORS[0].flow,
                size: 0.5,
                transparent: true, opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            const points = new THREE.Points(geo, matFlow);
            mainGroup.add(points);
            flowParticles = { mesh: points, phases: phases, speeds: speeds };
        }

        // --- 微细雪花 (Mod: 小而多) ---
        function createMicroSnow() {
            // 使用简单的圆形贴图或直接点
            const cvs = document.createElement('canvas');
            cvs.width = 32; cvs.height = 32;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(16,16,10,0,Math.PI*2); ctx.fill();
            const tex = new THREE.CanvasTexture(cvs);

            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const vels = [];
            for(let i=0; i<count; i++) {
                pos.push((Math.random()-0.5)*100, Math.random()*80-20, (Math.random()-0.5)*80);
                vels.push(0.05 + Math.random() * 0.15);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            
            matSnow = new THREE.PointsMaterial({
                color: COLORS[0].snow,
                map: tex,
                size: 0.4, // 小
                transparent: true, opacity: 0.8,
                alphaTest: 0.1,
                depthWrite: false
            });
            
            snowSystem = { mesh: new THREE.Points(geo, matSnow), vels: vels };
            // 雪花不随主体旋转，放 scene
            scene.add(snowSystem.mesh);
        }

        // --- 顶部大星星 ---
        function createTopStar() {
            const geo = new THREE.OctahedronGeometry(1.2, 0);
            matStar = new THREE.MeshBasicMaterial({ color: COLORS[0].main });
            starMesh = new THREE.Mesh(geo, matStar);
            
            // 外部光晕
            const glowGeo = new THREE.PlaneGeometry(6, 6);
            const cvs = document.createElement('canvas');
            cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(cvs);
            const matHalo = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.6, depthWrite: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide });
            const halo = new THREE.Mesh(glowGeo, matHalo);
            starMesh.add(halo);

            starMesh.position.set(0, TREE_HEIGHT/2 + 1, 0);
            mainGroup.add(starMesh);
        }

        // --- AI 加载 ---
        let handLandmarker;
        async function preloadAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                startBtn.disabled = false; startBtn.classList.add('ready'); startBtn.innerText = "OPEN MAGIC";
                loadingText.innerText = "SYSTEM READY";
            } catch (e) { loadingText.innerText = "AI ERROR"; }
        }
        
        async function startCamera() {
            const video = document.getElementById("video-preview");
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: 640, height: 480 } });
            video.srcObject = stream;
            return new Promise(r => video.onloadeddata = () => { video.play(); r(); });
        }

        function loadMMDModel(name) {
            new MMDLoader().load(MODELS[name], (mesh) => {
                if (currentModel) scene.remove(currentModel);
                currentModel = mesh;
                mesh.scale.set(1.5, 1.5, 1.5);
                mesh.position.set(-18, -12, -10); // 左后方
                mesh.lookAt(0, -2, 0); // 看向树中心
                mesh.material.forEach(m => {
                    m.emissive = new THREE.Color(0x222222); // 稍微亮一点适应暗场景
                    if(name==='usagi') m.color.setHex(0xFFEEAA);
                    if(name==='hachiware') m.color.setHex(0xDDEEFF);
                });
                scene.add(mesh);
            });
        }

        // --- 核心：变色触发 ---
        function triggerColorChange() {
            const now = Date.now();
            if (now - lastWaveTime < 500) return;
            lastWaveTime = now;

            colorState = (colorState + 1) % 3;
            const c = COLORS[colorState];

            // 1. 主体
            matMain.color.setHex(c.main);
            matMain.emissive.setHex(c.emissive);
            
            // 2. 星星
            matStar.color.setHex(c.main);

            // 3. 粒子与雪
            matFlow.color.setHex(c.flow);
            matSnow.color.setHex(c.snow);

            // 4. 极光 (Shader Uniform)
            // 使用 GSAP 或简单的 lerp 会更好，这里直接设值
            if(auroraMesh) {
                auroraMesh.material.uniforms.color.value = c.aurora;
            }

            debugColor.innerText = c.name;
            debugColor.style.color = '#' + c.main.toString(16);
        }

        // --- 逻辑循环 ---
        let lastVideoTime = -1;
        function updateLogic() {
            const video = document.getElementById("video-preview");
            if (!handLandmarker || !video || video.paused) return;

            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const res = handLandmarker.detectForVideo(video, performance.now());
                const msgBox = document.getElementById('message-box');
                const title = document.getElementById('top-title');

                if (res.landmarks && res.landmarks.length > 0) {
                    isHandDetected = true;
                    const lm = res.landmarks[0];
                    const wrist = lm[0];
                    
                    debugHand.innerText = "DETECTED"; debugHand.style.color = "#00ff00";

                    // 计算握拳
                    const tips = [8,12,16,20];
                    let dist = 0;
                    tips.forEach(i => dist += Math.sqrt(Math.pow(lm[i].x-wrist.x,2) + Math.pow(lm[i].y-wrist.y,2)));
                    dist /= 4;
                    let rawClench = THREE.MathUtils.mapLinear(dist, 0.45, 0.2, 0, 1);
                    handClenchLevel += (THREE.MathUtils.clamp(rawClench, 0, 1) - handClenchLevel) * 0.15;

                    // 状态判断
                    if (handClenchLevel > 0.8) {
                        targetShape = 'ball'; debugState.innerText = "SPHERE (Fist)"; debugState.style.color = "#ffff00";
                    } else if (handClenchLevel < 0.3) {
                        targetShape = 'explode'; debugState.innerText = "BURST (Palm)"; debugState.style.color = "#ff0055";
                    } else {
                        targetShape = 'tree'; debugState.innerText = "TREE (Relax)"; debugState.style.color = "#ffffff";
                    }

                    // 挥手变色
                    const rawX = 0.5 - wrist.x;
                    const delta = rawX - previousHandX;
                    if (Math.abs(delta) > 0.02) triggerColorChange();
                    previousHandX = rawX;

                    // OK手势
                    const pinch = Math.sqrt(Math.pow(lm[4].x-lm[8].x,2) + Math.pow(lm[4].y-lm[8].y,2));
                    if (pinch < 0.05) {
                        msgBox.style.display = 'block'; title.style.opacity = 0;
                    } else {
                        msgBox.style.display = 'none'; title.style.opacity = 1;
                    }

                } else {
                    isHandDetected = false;
                    targetShape = 'tree';
                    debugHand.innerText = "NO HAND"; debugHand.style.color = "#555";
                    debugState.innerText = "AUTO";
                }
            }
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            updateLogic();
            
            const time = Date.now() * 0.001;

            // 1. 极光动画
            if (auroraMesh) {
                auroraMesh.material.uniforms.time.value = time;
            }

            // 2. 形态插值因子 (0: Tree, 1: Ball)
            // 如果是 tree, target=0; ball, target=1; explode 处理在物理层
            let shapeTarget = (targetShape === 'ball') ? 1 : 0;
            // 缓动
            shapeLerpFactor += (shapeTarget - shapeLerpFactor) * 0.05;

            // 3. 主体旋转 (手控停止)
            if (isHandDetected) {
                mainGroup.rotation.y += 0.002; // 慢速
            } else {
                mainGroup.rotation.y += 0.005; // 自动
            }

            // 4. 积木物理 (核心美学逻辑)
            ornaments.forEach(p => {
                const cur = p.mesh.position;
                
                // 呼吸效果 (自转 + 微动)
                p.mesh.rotation.x += p.rotSpeed.x;
                p.mesh.rotation.y += p.rotSpeed.y;

                // 闪烁
                if (p.isGlow) {
                    p.mesh.material.emissiveIntensity = 1.5 + Math.sin(time * 3 + cur.x) * 1.0;
                }

                // 目标位置计算
                // Tree Pos <--> Ball Pos 插值
                const mixedTarget = new THREE.Vector3().copy(p.posTree).lerp(p.posBall, shapeLerpFactor);

                if (isHandDetected && targetShape === 'explode') {
                    // 爆炸模式：沿球体法线向外
                    p.velocity.copy(p.dirExplode).multiplyScalar(0.2); // 速度
                    cur.add(p.velocity);
                } else {
                    // 聚合模式 (Tree 或 Ball)
                    // 弹性吸附
                    cur.lerp(mixedTarget, 0.08); 
                    p.velocity.set(0,0,0);
                }
            });

            // 5. 顶部星星位置
            // 当变成球时，星星应该下沉到球心或者浮在球顶？
            // 设定：变成球时，星星下沉到中心充当核心
            const starTargetY = (targetShape === 'ball') ? 0 : (TREE_HEIGHT/2 + 1);
            starMesh.position.y += (starTargetY - starMesh.position.y) * 0.1;
            // 球体模式下星星变小
            const starTargetScale = (targetShape === 'ball') ? 0.1 : 1.0;
            const currentScale = starMesh.scale.x;
            const newScale = currentScale + (starTargetScale - currentScale) * 0.1;
            starMesh.scale.setScalar(newScale);

            // 6. 智能流光 (Mod: 随形而变)
            if (flowParticles.mesh) {
                const positions = flowParticles.mesh.geometry.attributes.position.array;
                for(let i=0; i<FLOW_COUNT; i++) {
                    const idx = i*3;
                    
                    // 时间偏移
                    const t = time * flowParticles.speeds[i] + flowParticles.phases[i];
                    
                    // 计算 Tree 状态下的半径 (圆锥)
                    // 高度 y 从 -10 到 10 循环
                    let y = ((t * 5) % (TREE_HEIGHT + 10)) - (TREE_HEIGHT/2 + 5);
                    if(y > TREE_HEIGHT/2) y = -TREE_HEIGHT/2; // 循环

                    const yNorm = (y + TREE_HEIGHT/2) / TREE_HEIGHT;
                    const rTree = (TREE_RADIUS_BASE + 2) * (1 - yNorm * 0.6); // 比树稍大
                    
                    // 计算 Ball 状态下的半径 (球壳)
                    const rBall = BALL_RADIUS + 3; // 比球稍大
                    
                    // 插值半径
                    const rCurrent = THREE.MathUtils.lerp(rTree, rBall, shapeLerpFactor);

                    // 爆炸扩散
                    let rFinal = rCurrent;
                    if (targetShape === 'explode') rFinal *= 2.5;

                    positions[idx] = Math.cos(t) * rFinal;   // X
                    positions[idx+1] = y * (1 - shapeLerpFactor); // Y (变成球时Y轴压缩到0附近? 不，球形粒子应该环绕)
                    
                    // 修正：球形模式下，粒子应该在球面乱飞，而不是圆柱
                    // 这里做一个简单的混合：如果变成球，Y轴也变成正弦波
                    if (shapeLerpFactor > 0.5) {
                        positions[idx+1] = Math.sin(t * 1.5) * rBall; 
                    }
                    
                    positions[idx+2] = Math.sin(t) * rFinal; // Z
                }
                flowParticles.mesh.geometry.attributes.position.needsUpdate = true;
            }

            // 7. 雪花下落
            if(snowSystem) {
                const positions = snowSystem.mesh.geometry.attributes.position.array;
                for(let i=0; i<snowSystem.vels.length; i++) {
                    positions[i*3+1] -= snowSystem.vels[i];
                    if (positions[i*3+1] < -20) positions[i*3+1] = 60;
                }
                snowSystem.mesh.geometry.attributes.position.needsUpdate = true;
            }

            // 8. 人物骨骼跟随
            if (currentModel && currentModel.skeleton) {
                 const bones = currentModel.skeleton.bones;
                 const armL = bones.find(b => b.name === '左腕');
                 const armR = bones.find(b => b.name === '右腕');
                 if (armL && armR) {
                     // 简单抬手动作
                     const z = THREE.MathUtils.lerp(-0.8, 0.4, handClenchLevel); 
                     armL.rotation.z = z; armR.rotation.z = -z;
                 }
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
